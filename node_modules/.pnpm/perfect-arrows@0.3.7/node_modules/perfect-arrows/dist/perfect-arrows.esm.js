var PI = Math.PI;
/**
 * Modulate a value between two ranges.
 * @param value
 * @param rangeA from [low, high]
 * @param rangeB to [low, high]
 * @param clamp
 */

function modulate(value, rangeA, rangeB, clamp) {
  if (clamp === void 0) {
    clamp = false;
  }

  var fromLow = rangeA[0],
      fromHigh = rangeA[1];
  var toLow = rangeB[0],
      toHigh = rangeB[1];
  var result = toLow + (value - fromLow) / (fromHigh - fromLow) * (toHigh - toLow);

  if (clamp === true) {
    if (toLow < toHigh) {
      if (result < toLow) {
        return toLow;
      }

      if (result > toHigh) {
        return toHigh;
      }
    } else {
      if (result > toLow) {
        return toLow;
      }

      if (result < toHigh) {
        return toHigh;
      }
    }
  }

  return result;
}
/**
 * Rotate a point around a center.
 * @param x The x-axis coordinate of the point.
 * @param y The y-axis coordinate of the point.
 * @param cx The x-axis coordinate of the point to rotate round.
 * @param cy The y-axis coordinate of the point to rotate round.
 * @param angle The distance (in radians) to rotate.
 */

function rotatePoint(x, y, cx, cy, angle) {
  var s = Math.sin(angle);
  var c = Math.cos(angle);
  var px = x - cx;
  var py = y - cy;
  var nx = px * c - py * s;
  var ny = px * s + py * c;
  return [nx + cx, ny + cy];
}
/**
 * Get the distance between two points.
 * @param x0 The x-axis coordinate of the first point.
 * @param y0 The y-axis coordinate of the first point.
 * @param x1 The x-axis coordinate of the second point.
 * @param y1 The y-axis coordinate of the second point.
 */

function getDistance(x0, y0, x1, y1) {
  return Math.hypot(y1 - y0, x1 - x0);
}
/**
 * Get an angle (radians) between two points.
 * @param x0 The x-axis coordinate of the first point.
 * @param y0 The y-axis coordinate of the first point.
 * @param x1 The x-axis coordinate of the second point.
 * @param y1 The y-axis coordinate of the second point.
 */

function getAngle(x0, y0, x1, y1) {
  return Math.atan2(y1 - y0, x1 - x0);
}
/**
 * Move a point in an angle by a distance.
 * @param x0
 * @param y0
 * @param a angle (radians)
 * @param d distance
 */

function projectPoint(x0, y0, a, d) {
  return [Math.cos(a) * d + x0, Math.sin(a) * d + y0];
}
/**
 * Get a point between two points.
 * @param x0 The x-axis coordinate of the first point.
 * @param y0 The y-axis coordinate of the first point.
 * @param x1 The x-axis coordinate of the second point.
 * @param y1 The y-axis coordinate of the second point.
 * @param d Normalized
 */

function getPointBetween(x0, y0, x1, y1, d) {
  if (d === void 0) {
    d = 0.5;
  }

  return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d];
}
/**
 * Get the sector of an angle (e.g. quadrant, octant)
 * @param a The angle to check.
 * @param s The number of sectors to check.
 */

function getSector(a, s) {
  if (s === void 0) {
    s = 8;
  }

  return Math.floor(s * (0.5 + a / (PI * 2) % s));
}
/**
 * Get a normal value representing how close two points are from being at a 45 degree angle.
 * @param x0 The x-axis coordinate of the first point.
 * @param y0 The y-axis coordinate of the first point.
 * @param x1 The x-axis coordinate of the second point.
 * @param y1 The y-axis coordinate of the second point.
 */

function getAngliness(x0, y0, x1, y1) {
  return Math.abs((x1 - x0) / 2 / ((y1 - y0) / 2));
}
/**
 * Check whether two rectangles will collide (overlap).
 * @param x0 The x-axis coordinate of the first rectangle.
 * @param y0 The y-axis coordinate of the first rectangle.
 * @param w0 The width of the first rectangle.
 * @param h0 The height of the first rectangle.
 * @param x1 The x-axis coordinate of the second rectangle.
 * @param y1 The y-axis coordinate of the second rectangle.
 * @param w1 The width of the second rectangle.
 * @param h1 The height of the second rectangle.
 */

function doRectanglesCollide(x0, y0, w0, h0, x1, y1, w1, h1) {
  return !(x0 >= x1 + w1 || x1 >= x0 + w0 || y0 >= y1 + h1 || y1 >= y0 + h0);
}
/**
 * Get the point(s) where a line segment intersects a circle.
 * @param cx The x-axis coordinate of the circle's center.
 * @param cy The y-axis coordinate of the circle's center.
 * @param r The circle's radius.
 * @param x0 The x-axis coordinate of the segment's starting point.
 * @param y0 The y-axis coordinate of ththe segment's ending point.
 * @param x1 The delta-x of the ray.
 * @param y1 The delta-y of the ray.
 */

function getSegmentCircleIntersections(cx, cy, r, x0, y0, x1, y1) {
  var b,
      c,
      d,
      u1,
      u2,
      ret,
      retP1,
      retP2,
      v1 = [x1 - x0, y1 - y0],
      v2 = [x0 - cx, y0 - cy];
  b = v1[0] * v2[0] + v1[1] * v2[1];
  c = 2 * (v1[0] * v1[0] + v1[1] * v1[1]);
  b *= -2;
  d = Math.sqrt(b * b - 2 * c * (v2[0] * v2[0] + v2[1] * v2[1] - r * r));

  if (isNaN(d)) {
    // no intercept
    return [];
  }

  u1 = (b - d) / c; // these represent the unit distance of point one and two on the line

  u2 = (b + d) / c;
  retP1 = []; // return points

  retP2 = [];
  ret = []; // return array

  if (u1 <= 1 && u1 >= 0) {
    // add point if on the line segment
    retP1[0] = x0 + v1[0] * u1;
    retP1[1] = y0 + v1[1] * u1;
    ret[0] = retP1;
  }

  if (u2 <= 1 && u2 >= 0) {
    // second add point if on the line segment
    retP2[0] = x0 + v1[0] * u2;
    retP2[1] = y0 + v1[1] * u2;
    ret[ret.length] = retP2;
  }

  return ret;
}
/**
 * Normalize an angle (in radians)
 * @param radians The radians quantity to normalize.
 */

function normalizeAngle(radians) {
  return radians - PI * 2 * Math.floor(radians / (PI * 2));
}
/**
 * Get the point at which a ray intersects a segment.
 * @param x The x-axis coordinate of the ray's origin.
 * @param y The y-axis coordinate of the ray's origin.
 * @param dx The x-axis delta of the angle.
 * @param dy The y-axis delta of the angle.
 * @param x0 The x-axis coordinate of the segment's start point.
 * @param y0 The y-axis coordinate of the segment's start point.
 * @param x1 The x-axis coordinate of the segment's end point.
 * @param y1 The y-axis coordinate of the segment's end point.
 */

function getRaySegmentIntersection(x, y, dx, dy, x0, y0, x1, y1) {
  var r, s, d;

  if (dy * (x1 - x0) !== dx * (y1 - y0)) {
    d = dx * (y1 - y0) - dy * (x1 - x0);

    if (d !== 0) {
      r = ((y - y0) * (x1 - x0) - (x - x0) * (y1 - y0)) / d;
      s = ((y - y0) * dx - (x - x0) * dy) / d;

      if (r >= 0 && s >= 0 && s <= 1) {
        return [x + r * dx, y + r * dy];
      }
    }
  }

  return undefined;
}
/**
 * Get the normalized delta (x and y) for an angle.
 * @param angle The angle in radians
 */

function getDelta(angle) {
  return [Math.cos(angle), Math.sin(angle)];
}
function getIntermediate(angle) {
  return Math.abs(Math.abs(angle % (PI / 2)) - PI / 4) / (PI / 4);
}
/**
 * Get a line between two rounded rectangles.
 * @param x0
 * @param y0
 * @param w0
 * @param h0
 * @param r0
 * @param x1
 * @param y1
 * @param w1
 * @param h1
 * @param r1
 */

function getLineBetweenRoundedRectangles(x0, y0, w0, h0, r0, x1, y1, w1, h1, r1) {
  var cx0 = x0 + w0 / 2,
      cy0 = y0 + h0 / 2,
      cx1 = x1 + w1 / 2,
      cy1 = y1 + h1 / 2,
      _ref3 = getRayRoundedRectangleIntersection(cx0, cy0, cx1 - cx0, cy1 - cy0, x0, y0, w0, h0, r0) || [[cx0, cy0]],
      _ref3$ = _ref3[0],
      di0x = _ref3$[0],
      di0y = _ref3$[1],
      _ref4 = getRayRoundedRectangleIntersection(cx1, cy1, cx0 - cx1, cy0 - cy1, x1, y1, w1, h1, r1) || [[cx1, cy1]],
      _ref4$ = _ref4[0],
      di1x = _ref4$[0],
      di1y = _ref4$[1];

  return [di0x, di0y, di1x, di1y];
}
/**
 * Get the intersection points between a ray and a rectangle with rounded corners.
 * @param ox The x-axis coordinate of the ray's origin.
 * @param oy The y-axis coordinate of the ray's origin.
 * @param dx The delta-x of the ray.
 * @param dy The delta-y of the ray.
 * @param x The x-axis coordinate of the rectangle.
 * @param y The y-axis coordinate of the rectangle.
 * @param w The width of the rectangle.
 * @param h The height of the rectangle.
 * @param r The corner radius of the rectangle.
 */

function getRayRoundedRectangleIntersection(ox, oy, dx, dy, x, y, w, h, r) {
  var mx = x + w,
      my = y + h,
      rx = x + r - 1,
      ry = y + r - 1,
      mrx = x + w - r + 1,
      mry = y + h - r + 1;
  var segments = [[x, mry, x, ry], [rx, y, mrx, y], [mx, ry, mx, mry], [mrx, my, rx, my]];
  var corners = [[rx, ry, Math.PI, Math.PI * 1.5], [mrx, ry, Math.PI * 1.5, Math.PI * 2], [mrx, mry, 0, Math.PI * 0.5], [rx, mry, Math.PI * 0.5, Math.PI]];
  var points = [];
  segments.forEach(function (segment, i) {
    var px0 = segment[0],
        py0 = segment[1],
        px1 = segment[2],
        py1 = segment[3];
    var _corners$i2 = corners[i],
        cx = _corners$i2[0],
        cy = _corners$i2[1],
        as = _corners$i2[2],
        ae = _corners$i2[3];
    var intersections = getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy);
    intersections && intersections.filter(function (pt) {
      var pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]));
      return pointAngle > as && pointAngle < ae;
    }).forEach(function (pt) {
      return points.push(pt);
    });
    var segmentInt = getRaySegmentIntersection(ox, oy, dx, dy, px0, py0, px1, py1);

    if (!!segmentInt) {
      points.push(segmentInt);
    }
  });
  return points;
}
function getRectangleSegmentIntersectedByRay(x, y, w, h, ox, oy, dx, dy) {
  return getRectangleSegments(x, y, w, h).find(function (_ref5) {
    var sx0 = _ref5[0],
        sy0 = _ref5[1],
        sx1 = _ref5[2],
        sy1 = _ref5[3];
    return getRaySegmentIntersection(ox, oy, dx, dy, sx0, sy0, sx1, sy1);
  });
}
function getRectangleSegments(x, y, w, h) {
  return [[x, y, x + w, y], [x + w, y, x + w, y + h], [x + w, y + h, x, y + h], [x, y + h, x, y]];
}
function getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy) {
  // This is a shitty hack
  return getSegmentCircleIntersections(cx, cy, r, ox, oy, dx * 999999, dy * 999999);
}

/**
 * getArrow
 * Get the points for a linking line between two points.
 * @description Draw an arrow between two points.
 * @param x0 The x position of the "from" point.
 * @param y0 The y position of the "from" point.
 * @param x1 The x position of the "to" point.
 * @param y1 The y position of the "to" point.
 * @param options Additional options for computing the line.
 * @returns [sx, sy, cx, cy, e1, e2, ae, as, ac]
 * @example
 * const arrow = getArrow(0, 0, 100, 200, {
    bow: 0
    stretch: .5
    stretchMin: 0
    stretchMax: 420
    padStart: 0
    padEnd: 0
    flip: false
    straights: true
 * })
 *
 * const [
 *  startX, startY,
 *  controlX, controlY,
 *  endX, endY,
 *  endAngle,
 *  startAngle,
 *  controlAngle
 *  ] = arrow
 */

function getArrow(x0, y0, x1, y1, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$bow = _options.bow,
      bow = _options$bow === void 0 ? 0 : _options$bow,
      _options$stretch = _options.stretch,
      stretch = _options$stretch === void 0 ? 0.5 : _options$stretch,
      _options$stretchMin = _options.stretchMin,
      stretchMin = _options$stretchMin === void 0 ? 0 : _options$stretchMin,
      _options$stretchMax = _options.stretchMax,
      stretchMax = _options$stretchMax === void 0 ? 420 : _options$stretchMax,
      _options$padStart = _options.padStart,
      padStart = _options$padStart === void 0 ? 0 : _options$padStart,
      _options$padEnd = _options.padEnd,
      padEnd = _options$padEnd === void 0 ? 0 : _options$padEnd,
      _options$flip = _options.flip,
      flip = _options$flip === void 0 ? false : _options$flip,
      _options$straights = _options.straights,
      straights = _options$straights === void 0 ? true : _options$straights;
  var angle = getAngle(x0, y0, x1, y1);
  var dist = getDistance(x0, y0, x1, y1);
  var angliness = getAngliness(x0, y0, x1, y1); // Step 0 ⤜⤏ Should the arrow be straight?

  if (dist < (padStart + padEnd) * 2 || bow === 0 && stretch === 0 || straights && [0, 1, Infinity].includes(angliness) // 45 degree angle
  ) {
    // ⤜⤏ Arrow is straight! Just pad start and end points.
    // Padding distances
    var ps = Math.max(0, Math.min(dist - padStart, padStart));
    var pe = Math.max(0, Math.min(dist - ps, padEnd)); // Move start point toward end point

    var _projectPoint = projectPoint(x0, y0, angle, ps),
        _px = _projectPoint[0],
        _py = _projectPoint[1]; // Move end point toward start point


    var _projectPoint2 = projectPoint(x1, y1, angle + Math.PI, pe),
        _px2 = _projectPoint2[0],
        _py2 = _projectPoint2[1]; // Get midpoint between new points


    var _getPointBetween = getPointBetween(_px, _py, _px2, _py2, 0.5),
        _mx = _getPointBetween[0],
        _my = _getPointBetween[1];

    return [_px, _py, _mx, _my, _px2, _py2, angle, angle, angle];
  } // ⤜⤏ Arrow is an arc!
  // Is the arc clockwise or counterclockwise?


  var rot = (getSector(angle) % 2 === 0 ? 1 : -1) * (flip ? -1 : 1); // Calculate how much the line should "bow" away from center

  var arc = bow + modulate(dist, [stretchMin, stretchMax], [1, 0], true) * stretch; // Step 1 ⤜⤏ Find padded points.
  // Get midpoint.

  var _getPointBetween2 = getPointBetween(x0, y0, x1, y1, 0.5),
      mx = _getPointBetween2[0],
      my = _getPointBetween2[1]; // Get control point.


  var _getPointBetween3 = getPointBetween(x0, y0, x1, y1, 0.5 - arc),
      cx = _getPointBetween3[0],
      cy = _getPointBetween3[1];

  var _rotatePoint = rotatePoint(cx, cy, mx, my, Math.PI / 2 * rot);

  cx = _rotatePoint[0];
  cy = _rotatePoint[1];
  // Get padded start point.
  var a0 = getAngle(x0, y0, cx, cy);

  var _projectPoint3 = projectPoint(x0, y0, a0, padStart),
      px0 = _projectPoint3[0],
      py0 = _projectPoint3[1]; // Get padded end point.


  var a1 = getAngle(x1, y1, cx, cy);

  var _projectPoint4 = projectPoint(x1, y1, a1, padEnd),
      px1 = _projectPoint4[0],
      py1 = _projectPoint4[1]; // Step 2  ⤜⤏ Find start and end angles.
  // Start angle


  var as = getAngle(cx, cy, x0, y0); // End angle

  var ae = getAngle(cx, cy, x1, y1); // Step 3 ⤜⤏ Find control point for padded points.
  // Get midpoint between padded start / end points.

  var _getPointBetween4 = getPointBetween(px0, py0, px1, py1, 0.5),
      mx1 = _getPointBetween4[0],
      my1 = _getPointBetween4[1]; // Get control point for padded start / end points.


  var _getPointBetween5 = getPointBetween(px0, py0, px1, py1, 0.5 - arc),
      cx1 = _getPointBetween5[0],
      cy1 = _getPointBetween5[1];

  var _rotatePoint2 = rotatePoint(cx1, cy1, mx1, my1, Math.PI / 2 * rot);

  cx1 = _rotatePoint2[0];
  cy1 = _rotatePoint2[1];

  // Finally, average the two control points.
  var _getPointBetween6 = getPointBetween(cx, cy, cx1, cy1, 0.5),
      cx2 = _getPointBetween6[0],
      cy2 = _getPointBetween6[1];

  return [px0, py0, cx2, cy2, px1, py1, ae, as, angle];
}

var PI$1 = Math.PI;
var PI2 = PI$1 * 2;
var MIN_ANGLE = PI$1 / 24;
/**
 * getArrowBetweenBoxes
 * Get the points for a linking line between two boxes.
 * @param x0 The x-axis coordinate of the first box.
 * @param y0 The y-axis coordinate of the first box.
 * @param w0 The width of the first box.
 * @param h0 The height of the first box.
 * @param x1 The x-axis coordinate of the second box.
 * @param y1 The y-axis coordinate of the second box.
 * @param w1 The width of the second box.
 * @param h1 The height of the second box.
 * @param options
 */

function getBoxToBoxArrow(x0, y0, w0, h0, x1, y1, w1, h1, options) {
  if (options === void 0) {
    options = {};
  }

  var sx, sy, ex, ey;
  var _options = options,
      _options$bow = _options.bow,
      bow = _options$bow === void 0 ? 0 : _options$bow,
      _options$stretch = _options.stretch,
      stretch = _options$stretch === void 0 ? 0.25 : _options$stretch,
      _options$stretchMin = _options.stretchMin,
      stretchMin = _options$stretchMin === void 0 ? 50 : _options$stretchMin,
      _options$stretchMax = _options.stretchMax,
      stretchMax = _options$stretchMax === void 0 ? 420 : _options$stretchMax,
      _options$padStart = _options.padStart,
      padStart = _options$padStart === void 0 ? 0 : _options$padStart,
      _options$padEnd = _options.padEnd,
      padEnd = _options$padEnd === void 0 ? 20 : _options$padEnd,
      _options$flip = _options.flip,
      flip = _options$flip === void 0 ? false : _options$flip,
      _options$straights = _options.straights,
      straights = _options$straights === void 0 ? true : _options$straights;
  var px0 = x0 - padStart,
      py0 = y0 - padStart,
      pw0 = w0 + padStart * 2,
      ph0 = h0 + padStart * 2,
      px1 = x1 - padEnd,
      py1 = y1 - padEnd,
      pw1 = w1 + padEnd * 2,
      ph1 = h1 + padEnd * 2,
      cx0 = x0 + w0 / 2,
      cy0 = y0 + h0 / 2,
      cx1 = x1 + w1 / 2,
      cy1 = y1 + h1 / 2; // Angle between centers

  var angle = normalizeAngle(getAngle(cx0, cy0, cx1, cy1)); // Distance between centers

  var distance = getDistance(cx0, cy0, cx1, cy1); // Perfect overlap, no arrow.

  if (distance === 0) {
    var _sx = cx0,
        _sy = py0;
    var _ex = cx1,
        _ey = py1;

    var _getPointBetween = getPointBetween(_sx, _sy, _ex, _ey, 0.5),
        cx = _getPointBetween[0],
        cy = _getPointBetween[1];

    var ca = getAngle(_sx, _sy, _ex, _ey);
    return [_sx, _sy, cx, cy, _ex, _ey, ca, ca, ca];
  } // Rotation of the arrow, clockwise or anticlockwise


  var rot = (getSector(angle) % 2 === 0 ? -1 : 1) * (flip ? -1 : 1); // How cardinal is the angle? 0 = 45deg, 1 = 90deg

  var card = getIntermediate(angle);
  if (card < 1 && card > 0.85) card = 0.99; // Are the boxes colliding / overlapping?

  var isColliding = doRectanglesCollide(px0, py0, pw0, ph0, px1, py1, pw1, ph1); // Direct line between boxes

  var _getLineBetweenRounde = getLineBetweenRoundedRectangles(px0, py0, pw0, ph0, padStart, px1, py1, pw1, ph1, padEnd),
      dix0 = _getLineBetweenRounde[0],
      diy0 = _getLineBetweenRounde[1],
      dix1 = _getLineBetweenRounde[2],
      diy1 = _getLineBetweenRounde[3]; // Length of the direct line between boxes


  var distanceBetween = getDistance(dix0, diy0, dix1, diy1);
  /* ------------- RETURN A STRAIGHT ARROW ------------ */
  // Should we just draw a straight line?

  if (!isColliding && straights && card % 0.5 === 0) {
    var _getPointBetween2 = getPointBetween(dix0, diy0, dix1, diy1, 0.5),
        mpdx = _getPointBetween2[0],
        mpdy = _getPointBetween2[1];

    return [dix0, diy0, mpdx, mpdy, dix1, diy1, angle, angle - PI$1, angle];
  }
  /* -------------- RETURN A CURVED ARROW ------------- */
  // How much are the two boxes overlapping?


  var overlapEffect = isColliding ? modulate(distanceBetween, [0, distance], [0, 1], true) : 0; // How far away are the two boxes?

  var distEffect = 1 - distanceBetween / distance; // How much should the stretch impact the arc?

  var stretchEffect = modulate(distanceBetween, [stretchMin, stretchMax], [1, 0], true); // What should the curved line's arc be?

  var arc = bow + stretchEffect * stretch; // How much should the angle's intermediacy (45degree-ness) affect the angle?

  var angleOffset = modulate(card * card, // a better curve here?
  [0, 1], [PI$1 * 0.125, 0], true);
  var distOffset = isColliding ? PI$1 * 0.5 * card : modulate(distEffect, // a better curve here?
  [0.75, 1], [0, PI$1 * 0.5], true) * card;
  var combinedOffset = distOffset + angleOffset * (isColliding ? 1 - overlapEffect : 1);
  /* ----------------- STARTING POINT ----------------- */
  // Angle of the first box

  var finalAngle0 = overlapEffect >= 0.5 ? angle + PI$1 * rot : angle + Math.max(MIN_ANGLE, combinedOffset) * rot; // Deltas of starting angle

  var _getDelta = getDelta(+(finalAngle0 % PI2).toPrecision(3)),
      dx0 = _getDelta[0],
      dy0 = _getDelta[1]; // Get ray intersection with rounded rectangle


  var _getRayRoundedRectang = getRayRoundedRectangleIntersection(cx0, cy0, dx0, dy0, px0, py0, pw0, ph0, padStart),
      _getRayRoundedRectang2 = _getRayRoundedRectang[0],
      tsx = _getRayRoundedRectang2[0],
      tsy = _getRayRoundedRectang2[1]; // Get midpoint of startingintersected segment


  var startSeg = getRectangleSegmentIntersectedByRay(px0, py0, pw0, ph0, cx0, cy0, dx0, dy0);
  if (!startSeg) throw Error; // Find start point (quarter way between segment midpoint and ray intersection)

  var ssx0 = startSeg[0],
      ssy0 = startSeg[1],
      ssx1 = startSeg[2],
      ssy1 = startSeg[3];

  var _getPointBetween3 = getPointBetween(ssx0, ssy0, ssx1, ssy1, 0.5),
      smpx = _getPointBetween3[0],
      smpy = _getPointBetween3[1];

  var _getPointBetween4 = getPointBetween(tsx, tsy, smpx, smpy, isColliding ? Math.max(overlapEffect, 0.15) : 0.15);

  sx = _getPointBetween4[0];
  sy = _getPointBetween4[1];
  arc *= 1 + (Math.max(-2, Math.min(distEffect, 2)) * card - overlapEffect) / 2;

  if (isColliding) {
    arc = arc < 0 ? Math.min(arc, -0.5) : Math.max(arc, 0.5);
  }
  /* ------------------ ENDING POINT ------------------ */


  if (overlapEffect >= 0.5) {
    // If overlapping, use the same angle as the start
    var rayAngle = getAngle(cx0, cy0, smpx, smpy);

    var _getDelta2 = getDelta(rayAngle),
        dx1 = _getDelta2[0],
        dy1 = _getDelta2[1];

    var _getRayRoundedRectang3 = getRayRoundedRectangleIntersection(cx1, cy1, dx1, dy1, px1, py1, pw1, ph1, padEnd);

    var _getRayRoundedRectang4 = _getRayRoundedRectang3[0];
    ex = _getRayRoundedRectang4[0];
    ey = _getRayRoundedRectang4[1];
  } else {
    // Calculate an angle based on distance, overlap and intermediacy
    var distOffset1 = modulate(distEffect, [0.75, 1], [0, 1], true);
    var overlapEffect1 = isColliding ? modulate(overlapEffect, [0, 1], [0, PI$1 / 8], true) : 0;
    var cardEffect1 = modulate(card * distOffset1, [0, 1], [0, PI$1 / 16], true);

    var _combinedOffset = distEffect * (PI$1 / 12) + (cardEffect1 + overlapEffect1) + (distOffset + angleOffset) / 2;

    var finalAngle1 = overlapEffect >= 0.5 ? angle + PI$1 * rot : angle + PI$1 - Math.max(_combinedOffset, MIN_ANGLE) * rot; // Deltas of ending angle

    var _getDelta3 = getDelta(+(finalAngle1 % PI2).toPrecision(3)),
        _dx = _getDelta3[0],
        _dy = _getDelta3[1]; // Get ray intersection with ending rounded rectangle


    var _getRayRoundedRectang5 = getRayRoundedRectangleIntersection(cx1, cy1, _dx, _dy, px1, py1, pw1, ph1, padEnd),
        _getRayRoundedRectang6 = _getRayRoundedRectang5[0],
        tex = _getRayRoundedRectang6[0],
        tey = _getRayRoundedRectang6[1]; // Get midpoint of ending intersected segment


    var endSeg = getRectangleSegmentIntersectedByRay(px1, py1, pw1, ph1, cx1, cy1, _dx, _dy);
    if (!endSeg) throw Error;
    var sex0 = endSeg[0],
        sey0 = endSeg[1],
        sex1 = endSeg[2],
        sey1 = endSeg[3];

    var _getPointBetween5 = getPointBetween(sex0, sey0, sex1, sey1, 0.5),
        empx = _getPointBetween5[0],
        empy = _getPointBetween5[1];

    var _getPointBetween6 = getPointBetween(tex, tey, empx, empy, 0.25 + overlapEffect * 0.25);

    ex = _getPointBetween6[0];
    ey = _getPointBetween6[1];
  }
  /* ------------------- DRAW ARROWS ------------------ */
  // Get midpoints.


  var _getPointBetween7 = getPointBetween(sx, sy, ex, ey, 0.5),
      mx1 = _getPointBetween7[0],
      my1 = _getPointBetween7[1];

  var _getPointBetween8 = getPointBetween(sx, sy, ex, ey, Math.max(-1, Math.min(1, 0.5 + arc)) // Clamped to 2
  ),
      tix = _getPointBetween8[0],
      tiy = _getPointBetween8[1]; // Rotate them (these are our two potential corners)


  var _rotatePoint = rotatePoint(tix, tiy, mx1, my1, PI$1 / 2 * rot),
      cixA = _rotatePoint[0],
      ciyA = _rotatePoint[1];

  var _rotatePoint2 = rotatePoint(tix, tiy, mx1, my1, PI$1 / 2 * -rot),
      cixB = _rotatePoint2[0],
      ciyB = _rotatePoint2[1]; // If we're colliding, pick the furthest corner from the end point.


  var _ref = isColliding && getDistance(cixA, ciyA, cx1, cy1) < getDistance(cixB, ciyB, cx1, cy1) ? [cixB, ciyB] : [cixA, ciyA],
      cix = _ref[0],
      ciy = _ref[1]; // Start and end angles


  var as = getAngle(cix, ciy, sx, sy);
  var ae = getAngle(cix, ciy, ex, ey);
  return [sx, sy, cix, ciy, ex, ey, ae, as, getAngle(sx, sy, ex, ey)];
}

export { getArrow, getBoxToBoxArrow };
//# sourceMappingURL=perfect-arrows.esm.js.map
