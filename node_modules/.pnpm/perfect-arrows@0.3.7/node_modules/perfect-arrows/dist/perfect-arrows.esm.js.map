{"version":3,"file":"perfect-arrows.esm.js","sources":["../src/lib/utils.ts","../src/lib/getArrow.ts","../src/lib/getBoxToBoxArrow.ts"],"sourcesContent":["const PI = Math.PI\n\n/**\n * Modulate a value between two ranges.\n * @param value\n * @param rangeA from [low, high]\n * @param rangeB to [low, high]\n * @param clamp\n */\nexport function modulate(\n  value: number,\n  rangeA: number[],\n  rangeB: number[],\n  clamp = false\n) {\n  const [fromLow, fromHigh] = rangeA\n  const [toLow, toHigh] = rangeB\n  const result =\n    toLow + ((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow)\n  if (clamp === true) {\n    if (toLow < toHigh) {\n      if (result < toLow) {\n        return toLow\n      }\n      if (result > toHigh) {\n        return toHigh\n      }\n    } else {\n      if (result > toLow) {\n        return toLow\n      }\n      if (result < toHigh) {\n        return toHigh\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Rotate a point around a center.\n * @param x The x-axis coordinate of the point.\n * @param y The y-axis coordinate of the point.\n * @param cx The x-axis coordinate of the point to rotate round.\n * @param cy The y-axis coordinate of the point to rotate round.\n * @param angle The distance (in radians) to rotate.\n */\nexport function rotatePoint(\n  x: number,\n  y: number,\n  cx: number,\n  cy: number,\n  angle: number\n) {\n  const s = Math.sin(angle)\n  const c = Math.cos(angle)\n\n  const px = x - cx\n  const py = y - cy\n\n  const nx = px * c - py * s\n  const ny = px * s + py * c\n\n  return [nx + cx, ny + cy]\n}\n\n/**\n * Get the distance between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getDistance(x0: number, y0: number, x1: number, y1: number) {\n  return Math.hypot(y1 - y0, x1 - x0)\n}\n\n/**\n * Get an angle (radians) between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getAngle(x0: number, y0: number, x1: number, y1: number) {\n  return Math.atan2(y1 - y0, x1 - x0)\n}\n\n/**\n * Move a point in an angle by a distance.\n * @param x0\n * @param y0\n * @param a angle (radians)\n * @param d distance\n */\nexport function projectPoint(x0: number, y0: number, a: number, d: number) {\n  return [Math.cos(a) * d + x0, Math.sin(a) * d + y0]\n}\n\n/**\n * Get a point between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n * @param d Normalized\n */\nexport function getPointBetween(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  d = 0.5\n) {\n  return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d]\n}\n\n/**\n * Get the sector of an angle (e.g. quadrant, octant)\n * @param a The angle to check.\n * @param s The number of sectors to check.\n */\nexport function getSector(a: number, s = 8) {\n  return Math.floor(s * (0.5 + ((a / (PI * 2)) % s)))\n}\n\n/**\n * Get a normal value representing how close two points are from being at a 45 degree angle.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getAngliness(x0: number, y0: number, x1: number, y1: number) {\n  return Math.abs((x1 - x0) / 2 / ((y1 - y0) / 2))\n}\n\n/**\n * Get the points at which an ellipse intersects a rectangle.\n * @param x\n * @param y\n * @param w\n * @param h\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param angle\n */\nexport function getEllipseRectangleIntersectionPoints(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  angle: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getEllipseSegmentIntersections(\n      px0,\n      py0,\n      px1,\n      py1,\n      cx,\n      cy,\n      rx,\n      ry,\n      angle\n    )\n\n    if (ints.length > 0) {\n      points.push(...ints)\n    }\n  }\n\n  points = points.sort(([x0, y0], [x1, y1]) => {\n    return Math.sin(getAngle(cx, cy, x0, y0) - getAngle(cx, cy, x1, y1)) > 0\n      ? -1\n      : 1\n  })\n\n  return points\n}\n\n/**\n * Find the point(s) where a line segment intersects an ellipse.\n * @param x0 The x-axis coordinate of the line's start point.\n * @param y0 The y-axis coordinate of the line's start point.\n * @param x1 The x-axis coordinate of the line's end point.\n * @param y1 The y-axis coordinate of the line's end point.\n * @param cx The x-axis (horizontal) coordinate of the ellipse's center.\n * @param cy The y-axis (vertical) coordinate of the ellipse's center.\n * @param rx The ellipse's major-axis radius. Must be non-negative.\n * @param ry The ellipse's minor-axis radius. Must be non-negative.\n * @param rotation The rotation of the ellipse, expressed in radians.\n * @param segment_only When true, will test the segment as a line (of infinite length).\n */\nexport function getEllipseSegmentIntersections(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  rotation = 0,\n  segment_only = true\n) {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || (x0 === x1 && y0 === y1)) {\n    return []\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points.\n  if (rotation !== 0) {\n    ;[x0, y0] = rotatePoint(x0, y0, cx, cy, -rotation)\n    ;[x1, y1] = rotatePoint(x1, y1, cx, cy, -rotation)\n  }\n\n  // Translate so the ellipse is centered at the origin.\n  x0 -= cx\n  y0 -= cy\n  x1 -= cx\n  y1 -= cy\n\n  // Calculate the quadratic parameters.\n  var A = ((x1 - x0) * (x1 - x0)) / rx / rx + ((y1 - y0) * (y1 - y0)) / ry / ry\n  var B = (2 * x0 * (x1 - x0)) / rx / rx + (2 * y0 * (y1 - y0)) / ry / ry\n  var C = (x0 * x0) / rx / rx + (y0 * y0) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  var tValues: number[] = []\n\n  // Calculate the discriminant.\n  var discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    // Two real solutions.\n    tValues.push((-B + Math.sqrt(discriminant)) / 2 / A)\n    tValues.push((-B - Math.sqrt(discriminant)) / 2 / A)\n  }\n\n  return (\n    tValues\n      // Filter to only points that are on the segment.\n      .filter(t => !segment_only || (t >= 0 && t <= 1))\n      // Solve for points.\n      .map(t => [x0 + (x1 - x0) * t + cx, y0 + (y1 - y0) * t + cy])\n      // Counter-rotate points\n      .map(p =>\n        rotation === 0 ? p : rotatePoint(p[0], p[1], cx, cy, rotation)\n      )\n  )\n}\n\n/**\n * Check whether two rectangles will collide (overlap).\n * @param x0 The x-axis coordinate of the first rectangle.\n * @param y0 The y-axis coordinate of the first rectangle.\n * @param w0 The width of the first rectangle.\n * @param h0 The height of the first rectangle.\n * @param x1 The x-axis coordinate of the second rectangle.\n * @param y1 The y-axis coordinate of the second rectangle.\n * @param w1 The width of the second rectangle.\n * @param h1 The height of the second rectangle.\n */\nexport function doRectanglesCollide(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number\n) {\n  return !(x0 >= x1 + w1 || x1 >= x0 + w0 || y0 >= y1 + h1 || y1 >= y0 + h0)\n}\n\n/**\n * Find the point(s) where a segment intersects a rectangle.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of the segment's starting point.\n * @param x1 The x-axis coordinate of the segment's ending point.\n * @param y1 The y-axis coordinate of the segment's ending point.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n */\nexport function getSegmentRectangleIntersectionPoints(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getSegmentSegmentIntersection(\n      px0,\n      py0,\n      px1,\n      py1,\n      x0,\n      y0,\n      x1,\n      y1\n    )\n    if (ints) {\n      points.push(ints)\n    }\n  }\n\n  return points\n}\n\n/**\n * Find the point, if any, where two segments intersect.\n * @param x0 The x-axis coordinate of the first segment's starting point.\n * @param y0 The y-axis coordinate of the first segment's starting point.\n * @param x1 The x-axis coordinate of the first segment's ending point.\n * @param y1 The y-axis coordinate of the first segment's ending point.\n * @param x2 The x-axis coordinate of the second segment's starting point.\n * @param y2 The y-axis coordinate of the second segment's starting point.\n * @param x3 The x-axis coordinate of the second segment's ending point.\n * @param y3 The y-axis coordinate of the second segment's ending point.\n */\nexport function getSegmentSegmentIntersection(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number\n) {\n  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0)\n  const numeA = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2)\n  const numeB = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2)\n\n  if (denom === 0) {\n    if (numeA === 0 && numeB === 0) {\n      return undefined // Colinear\n    }\n    return undefined // Parallel\n  }\n\n  const uA = numeA / denom\n  const uB = numeB / denom\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return [x0 + uA * (x1 - x0), y0 + uA * (y1 - y0)]\n  }\n\n  return undefined // No intersection\n}\n\n/**\n * Get the intersection points between a line segment and a rectangle with rounded corners.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of the segment's ending point.\n * @param x1 The delta-x of the ray.\n * @param y1 The delta-y of the ray.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n * @param r The corner radius of the rectangle.\n */\nexport function getSegmentRoundedRectangleIntersectionPoints(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const mx = x + w,\n    my = y + h,\n    rx = x + r,\n    ry = y + r,\n    mrx = x + w - r,\n    mry = y + h - r\n\n  const segments = [\n    [x, mry, x, ry, x, y],\n    [rx, y, mrx, y, mx, y],\n    [mx, ry, mx, mry, mx, my],\n    [mrx, my, rx, my, x, my],\n  ]\n\n  const corners = [\n    [rx, ry, PI, PI * 1.5],\n    [mrx, ry, PI * 1.5, PI * 2],\n    [mrx, mry, 0, PI * 0.5],\n    [rx, mry, PI * 0.5, PI],\n  ]\n\n  let points: number[][] = []\n\n  segments.forEach((segment, i) => {\n    const [px0, py0, px1, py1] = segment\n    const [cx, cy, as, ae] = corners[i]\n\n    getSegmentCircleIntersections(cx, cy, r, x0, y0, x1, y1)\n      .filter(pt => {\n        const pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]))\n        return pointAngle > as && pointAngle < ae\n      })\n      .forEach(pt => points.push(pt))\n\n    const segmentInt = getSegmentSegmentIntersection(\n      x0,\n      y0,\n      x1,\n      y1,\n      px0,\n      py0,\n      px1,\n      py1\n    )\n\n    if (!!segmentInt) {\n      points.push(segmentInt)\n    }\n  })\n\n  return points\n}\n\n/**\n * Get the point(s) where a line segment intersects a circle.\n * @param cx The x-axis coordinate of the circle's center.\n * @param cy The y-axis coordinate of the circle's center.\n * @param r The circle's radius.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of ththe segment's ending point.\n * @param x1 The delta-x of the ray.\n * @param y1 The delta-y of the ray.\n */\nexport function getSegmentCircleIntersections(\n  cx: number,\n  cy: number,\n  r: number,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) {\n  var b: number,\n    c: number,\n    d: number,\n    u1: number,\n    u2: number,\n    ret: number[][],\n    retP1: number[],\n    retP2: number[],\n    v1 = [x1 - x0, y1 - y0],\n    v2 = [x0 - cx, y0 - cy]\n\n  b = v1[0] * v2[0] + v1[1] * v2[1]\n  c = 2 * (v1[0] * v1[0] + v1[1] * v1[1])\n  b *= -2\n  d = Math.sqrt(b * b - 2 * c * (v2[0] * v2[0] + v2[1] * v2[1] - r * r))\n  if (isNaN(d)) {\n    // no intercept\n    return []\n  }\n  u1 = (b - d) / c // these represent the unit distance of point one and two on the line\n  u2 = (b + d) / c\n  retP1 = [] // return points\n  retP2 = []\n  ret = [] // return array\n\n  if (u1 <= 1 && u1 >= 0) {\n    // add point if on the line segment\n    retP1[0] = x0 + v1[0] * u1\n    retP1[1] = y0 + v1[1] * u1\n    ret[0] = retP1\n  }\n\n  if (u2 <= 1 && u2 >= 0) {\n    // second add point if on the line segment\n    retP2[0] = x0 + v1[0] * u2\n    retP2[1] = y0 + v1[1] * u2\n    ret[ret.length] = retP2\n  }\n\n  return ret\n}\n\n/**\n * Normalize an angle (in radians)\n * @param radians The radians quantity to normalize.\n */\nexport function normalizeAngle(radians: number) {\n  return radians - PI * 2 * Math.floor(radians / (PI * 2))\n}\n\n/**\n *\n * @param x The x-axis coordinate of the ray's origin.\n * @param y The y-axis coordinate of the ray's origin.\n * @param w\n * @param h\n * @param x0\n * @param y0\n * @param x1\n * @param y1\n */\nexport function getRayRectangleIntersectionPoints(\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getRaySegmentIntersection(ox, oy, dx, dy, px0, py0, px1, py1)\n    if (ints) {\n      points.push(ints)\n    }\n  }\n\n  return points\n}\n\n/**\n * Get the point at which a ray intersects a segment.\n * @param x The x-axis coordinate of the ray's origin.\n * @param y The y-axis coordinate of the ray's origin.\n * @param dx The x-axis delta of the angle.\n * @param dy The y-axis delta of the angle.\n * @param x0 The x-axis coordinate of the segment's start point.\n * @param y0 The y-axis coordinate of the segment's start point.\n * @param x1 The x-axis coordinate of the segment's end point.\n * @param y1 The y-axis coordinate of the segment's end point.\n */\nexport function getRaySegmentIntersection(\n  x: number,\n  y: number,\n  dx: number,\n  dy: number,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) {\n  let r: number, s: number, d: number\n\n  if (dy * (x1 - x0) !== dx * (y1 - y0)) {\n    d = dx * (y1 - y0) - dy * (x1 - x0)\n    if (d !== 0) {\n      r = ((y - y0) * (x1 - x0) - (x - x0) * (y1 - y0)) / d\n      s = ((y - y0) * dx - (x - x0) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return [x + r * dx, y + r * dy]\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * Get the normalized delta (x and y) for an angle.\n * @param angle The angle in radians\n */\nexport function getDelta(angle: number) {\n  return [Math.cos(angle), Math.sin(angle)]\n}\n\nexport function getIntermediate(angle: number) {\n  return Math.abs(Math.abs(angle % (PI / 2)) - PI / 4) / (PI / 4)\n}\n\n/**\n * Get a line between two rounded rectangles.\n * @param x0\n * @param y0\n * @param w0\n * @param h0\n * @param r0\n * @param x1\n * @param y1\n * @param w1\n * @param h1\n * @param r1\n */\nexport function getLineBetweenRoundedRectangles(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  r0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  r1: number\n) {\n  const cx0 = x0 + w0 / 2,\n    cy0 = y0 + h0 / 2,\n    cx1 = x1 + w1 / 2,\n    cy1 = y1 + h1 / 2,\n    [[di0x, di0y]] = getRayRoundedRectangleIntersection(\n      cx0,\n      cy0,\n      cx1 - cx0,\n      cy1 - cy0,\n      x0,\n      y0,\n      w0,\n      h0,\n      r0\n    ) || [[cx0, cy0]],\n    [[di1x, di1y]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      cx0 - cx1,\n      cy0 - cy1,\n      x1,\n      y1,\n      w1,\n      h1,\n      r1\n    ) || [[cx1, cy1]]\n\n  return [di0x, di0y, di1x, di1y]\n}\n\n/**\n * Get the intersection points between a ray and a rectangle with rounded corners.\n * @param ox The x-axis coordinate of the ray's origin.\n * @param oy The y-axis coordinate of the ray's origin.\n * @param dx The delta-x of the ray.\n * @param dy The delta-y of the ray.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n * @param r The corner radius of the rectangle.\n */\nexport function getRayRoundedRectangleIntersection(\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const mx = x + w,\n    my = y + h,\n    rx = x + r - 1,\n    ry = y + r - 1,\n    mrx = x + w - r + 1,\n    mry = y + h - r + 1\n\n  const segments = [\n    [x, mry, x, ry],\n    [rx, y, mrx, y],\n    [mx, ry, mx, mry],\n    [mrx, my, rx, my],\n  ]\n\n  const corners = [\n    [rx, ry, Math.PI, Math.PI * 1.5],\n    [mrx, ry, Math.PI * 1.5, Math.PI * 2],\n    [mrx, mry, 0, Math.PI * 0.5],\n    [rx, mry, Math.PI * 0.5, Math.PI],\n  ]\n\n  let points: number[][] = []\n\n  segments.forEach((segment, i) => {\n    const [px0, py0, px1, py1] = segment\n    const [cx, cy, as, ae] = corners[i]\n\n    const intersections = getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy)\n\n    intersections &&\n      intersections\n        .filter(pt => {\n          const pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]))\n          return pointAngle > as && pointAngle < ae\n        })\n        .forEach(pt => points.push(pt))\n\n    const segmentInt = getRaySegmentIntersection(\n      ox,\n      oy,\n      dx,\n      dy,\n      px0,\n      py0,\n      px1,\n      py1\n    )\n\n    if (!!segmentInt) {\n      points.push(segmentInt)\n    }\n  })\n\n  return points\n}\n\nexport function getRectangleSegmentIntersectedByRay(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number\n) {\n  return getRectangleSegments(x, y, w, h).find(([sx0, sy0, sx1, sy1]) =>\n    getRaySegmentIntersection(ox, oy, dx, dy, sx0, sy0, sx1, sy1)\n  )\n}\n\nexport function getRectangleSegments(\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  return [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]\n}\n\nexport function getRoundedRectangleSegments(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const rx = x + r,\n    ry = y + r,\n    mx = x + w,\n    my = y + h,\n    mrx = x + w - r,\n    mry = y + h - r\n\n  return [\n    [x, mry, x, ry, x, y],\n    [rx, y, mrx, y, mx, y],\n    [mx, ry, mx, mry, mx, my],\n    [mrx, my, rx, my, x, my],\n  ]\n}\n\nexport function getRayCircleIntersection(\n  cx: number,\n  cy: number,\n  r: number,\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number\n) {\n  // This is a shitty hack\n  return getSegmentCircleIntersections(\n    cx,\n    cy,\n    r,\n    ox,\n    oy,\n    dx * 999999,\n    dy * 999999\n  )\n}\n","import {\n  getAngle,\n  getDistance,\n  getAngliness,\n  projectPoint,\n  getPointBetween,\n  getSector,\n  rotatePoint,\n  modulate,\n} from \"./utils\"\n\nexport type ArrowOptions = {\n  bow?: number\n  stretchMin?: number\n  stretchMax?: number\n  stretch?: number\n  padStart?: number\n  padEnd?: number\n  flip?: boolean\n  straights?: boolean\n}\n\n/**\n * getArrow\n * Get the points for a linking line between two points.\n * @description Draw an arrow between two points.\n * @param x0 The x position of the \"from\" point.\n * @param y0 The y position of the \"from\" point.\n * @param x1 The x position of the \"to\" point.\n * @param y1 The y position of the \"to\" point.\n * @param options Additional options for computing the line.\n * @returns [sx, sy, cx, cy, e1, e2, ae, as, ac]\n * @example\n * const arrow = getArrow(0, 0, 100, 200, {\n    bow: 0\n    stretch: .5\n    stretchMin: 0\n    stretchMax: 420\n    padStart: 0\n    padEnd: 0\n    flip: false\n    straights: true\n * })\n * \n * const [\n *  startX, startY, \n *  controlX, controlY, \n *  endX, endY, \n *  endAngle, \n *  startAngle,\n *  controlAngle\n *  ] = arrow\n */\nexport default function getArrow(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  options: ArrowOptions = {} as ArrowOptions\n): number[] {\n  const {\n    bow = 0,\n    stretch = 0.5,\n    stretchMin = 0,\n    stretchMax = 420,\n    padStart = 0,\n    padEnd = 0,\n    flip = false,\n    straights = true,\n  } = options\n\n  const angle = getAngle(x0, y0, x1, y1)\n  const dist = getDistance(x0, y0, x1, y1)\n  const angliness = getAngliness(x0, y0, x1, y1)\n\n  // Step 0 ⤜⤏ Should the arrow be straight?\n\n  if (\n    dist < (padStart + padEnd) * 2 || // Too short\n    (bow === 0 && stretch === 0) || // No bow, no stretch\n    (straights && [0, 1, Infinity].includes(angliness)) // 45 degree angle\n  ) {\n    // ⤜⤏ Arrow is straight! Just pad start and end points.\n\n    // Padding distances\n    const ps = Math.max(0, Math.min(dist - padStart, padStart))\n    const pe = Math.max(0, Math.min(dist - ps, padEnd))\n\n    // Move start point toward end point\n    let [px0, py0] = projectPoint(x0, y0, angle, ps)\n\n    // Move end point toward start point\n    let [px1, py1] = projectPoint(x1, y1, angle + Math.PI, pe)\n\n    // Get midpoint between new points\n    const [mx, my] = getPointBetween(px0, py0, px1, py1, 0.5)\n\n    return [px0, py0, mx, my, px1, py1, angle, angle, angle]\n  }\n\n  // ⤜⤏ Arrow is an arc!\n\n  // Is the arc clockwise or counterclockwise?\n  let rot = (getSector(angle) % 2 === 0 ? 1 : -1) * (flip ? -1 : 1)\n\n  // Calculate how much the line should \"bow\" away from center\n  const arc =\n    bow + modulate(dist, [stretchMin, stretchMax], [1, 0], true) * stretch\n\n  // Step 1 ⤜⤏ Find padded points.\n\n  // Get midpoint.\n  const [mx, my] = getPointBetween(x0, y0, x1, y1, 0.5)\n\n  // Get control point.\n  let [cx, cy] = getPointBetween(x0, y0, x1, y1, 0.5 - arc)\n\n    // Rotate control point (clockwise or counterclockwise).\n  ;[cx, cy] = rotatePoint(cx, cy, mx, my, (Math.PI / 2) * rot)\n\n  // Get padded start point.\n  const a0 = getAngle(x0, y0, cx, cy)\n  const [px0, py0] = projectPoint(x0, y0, a0, padStart)\n\n  // Get padded end point.\n  const a1 = getAngle(x1, y1, cx, cy)\n  const [px1, py1] = projectPoint(x1, y1, a1, padEnd)\n\n  // Step 2  ⤜⤏ Find start and end angles.\n\n  // Start angle\n  const as = getAngle(cx, cy, x0, y0)\n\n  // End angle\n  const ae = getAngle(cx, cy, x1, y1)\n\n  // Step 3 ⤜⤏ Find control point for padded points.\n\n  // Get midpoint between padded start / end points.\n  const [mx1, my1] = getPointBetween(px0, py0, px1, py1, 0.5)\n\n  // Get control point for padded start / end points.\n  let [cx1, cy1] = getPointBetween(px0, py0, px1, py1, 0.5 - arc)\n\n    // Rotate control point (clockwise or counterclockwise).\n  ;[cx1, cy1] = rotatePoint(cx1, cy1, mx1, my1, (Math.PI / 2) * rot)\n\n  // Finally, average the two control points.\n  let [cx2, cy2] = getPointBetween(cx, cy, cx1, cy1, 0.5)\n\n  return [px0, py0, cx2, cy2, px1, py1, ae, as, angle]\n}\n","import {\n  getDistance,\n  getSector,\n  modulate,\n  getDelta,\n  getAngle,\n  rotatePoint,\n  getPointBetween,\n  doRectanglesCollide,\n  getIntermediate,\n  getLineBetweenRoundedRectangles,\n  normalizeAngle,\n  getRayRoundedRectangleIntersection,\n  getRectangleSegmentIntersectedByRay,\n} from \"./utils\"\n\nexport type ArrowOptions = {\n  bow?: number\n  stretchMin?: number\n  stretchMax?: number\n  stretch?: number\n  padStart?: number\n  padEnd?: number\n  flip?: boolean\n  straights?: boolean\n}\n\nconst PI = Math.PI\nconst PI2 = PI * 2\nconst MIN_ANGLE = PI / 24\n\n/**\n * getArrowBetweenBoxes\n * Get the points for a linking line between two boxes.\n * @param x0 The x-axis coordinate of the first box.\n * @param y0 The y-axis coordinate of the first box.\n * @param w0 The width of the first box.\n * @param h0 The height of the first box.\n * @param x1 The x-axis coordinate of the second box.\n * @param y1 The y-axis coordinate of the second box.\n * @param w1 The width of the second box.\n * @param h1 The height of the second box.\n * @param options\n */\nexport default function getBoxToBoxArrow(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  options: ArrowOptions = {} as ArrowOptions\n) {\n  let sx: number, sy: number, ex: number, ey: number\n\n  const {\n    bow = 0,\n    stretch = 0.25,\n    stretchMin = 50,\n    stretchMax = 420,\n    padStart = 0,\n    padEnd = 20,\n    flip = false,\n    straights = true,\n  } = options\n\n  const px0 = x0 - padStart,\n    py0 = y0 - padStart,\n    pw0 = w0 + padStart * 2,\n    ph0 = h0 + padStart * 2,\n    px1 = x1 - padEnd,\n    py1 = y1 - padEnd,\n    pw1 = w1 + padEnd * 2,\n    ph1 = h1 + padEnd * 2,\n    cx0 = x0 + w0 / 2,\n    cy0 = y0 + h0 / 2,\n    cx1 = x1 + w1 / 2,\n    cy1 = y1 + h1 / 2\n\n  // Angle between centers\n  const angle = normalizeAngle(getAngle(cx0, cy0, cx1, cy1))\n\n  // Distance between centers\n  const distance = getDistance(cx0, cy0, cx1, cy1)\n\n  // Perfect overlap, no arrow.\n  if (distance === 0) {\n    const [sx, sy] = [cx0, py0]\n    const [ex, ey] = [cx1, py1]\n    const [cx, cy] = getPointBetween(sx, sy, ex, ey, 0.5)\n    const ca = getAngle(sx, sy, ex, ey)\n    return [sx, sy, cx, cy, ex, ey, ca, ca, ca]\n  }\n\n  // Rotation of the arrow, clockwise or anticlockwise\n  const rot = (getSector(angle) % 2 === 0 ? -1 : 1) * (flip ? -1 : 1)\n\n  // How cardinal is the angle? 0 = 45deg, 1 = 90deg\n  let card = getIntermediate(angle)\n\n  if (card < 1 && card > 0.85) card = 0.99\n\n  // Are the boxes colliding / overlapping?\n  const isColliding = doRectanglesCollide(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    px1,\n    py1,\n    pw1,\n    ph1\n  )\n\n  // Direct line between boxes\n  const [dix0, diy0, dix1, diy1] = getLineBetweenRoundedRectangles(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    padStart,\n    px1,\n    py1,\n    pw1,\n    ph1,\n    padEnd\n  )\n\n  // Length of the direct line between boxes\n  const distanceBetween = getDistance(dix0, diy0, dix1, diy1)\n\n  /* ------------- RETURN A STRAIGHT ARROW ------------ */\n\n  // Should we just draw a straight line?\n  if (!isColliding && straights && card % 0.5 === 0) {\n    const [mpdx, mpdy] = getPointBetween(dix0, diy0, dix1, diy1, 0.5)\n    return [dix0, diy0, mpdx, mpdy, dix1, diy1, angle, angle - PI, angle]\n  }\n\n  /* -------------- RETURN A CURVED ARROW ------------- */\n\n  // How much are the two boxes overlapping?\n  let overlapEffect = isColliding\n    ? modulate(distanceBetween, [0, distance], [0, 1], true)\n    : 0\n\n  // How far away are the two boxes?\n  const distEffect = 1 - distanceBetween / distance\n\n  // How much should the stretch impact the arc?\n  const stretchEffect = modulate(\n    distanceBetween,\n    [stretchMin, stretchMax],\n    [1, 0],\n    true\n  )\n\n  // What should the curved line's arc be?\n  let arc = bow + stretchEffect * stretch\n\n  // How much should the angle's intermediacy (45degree-ness) affect the angle?\n  let angleOffset = modulate(\n    card * card, // a better curve here?\n    [0, 1],\n    [PI * 0.125, 0],\n    true\n  )\n\n  const distOffset = isColliding\n    ? PI * 0.5 * card\n    : modulate(\n        distEffect, // a better curve here?\n        [0.75, 1],\n        [0, PI * 0.5],\n        true\n      ) * card\n\n  const combinedOffset =\n    distOffset + angleOffset * (isColliding ? 1 - overlapEffect : 1)\n\n  /* ----------------- STARTING POINT ----------------- */\n\n  // Angle of the first box\n  let finalAngle0 =\n    overlapEffect >= 0.5\n      ? angle + PI * rot\n      : angle + Math.max(MIN_ANGLE, combinedOffset) * rot\n\n  // Deltas of starting angle\n  const [dx0, dy0] = getDelta(+(finalAngle0 % PI2).toPrecision(3))\n\n  // Get ray intersection with rounded rectangle\n  const [[tsx, tsy]] = getRayRoundedRectangleIntersection(\n    cx0,\n    cy0,\n    dx0,\n    dy0,\n    px0,\n    py0,\n    pw0,\n    ph0,\n    padStart\n  )\n\n  // Get midpoint of startingintersected segment\n  const startSeg = getRectangleSegmentIntersectedByRay(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    cx0,\n    cy0,\n    dx0,\n    dy0\n  )\n\n  if (!startSeg) throw Error\n\n  // Find start point (quarter way between segment midpoint and ray intersection)\n  const [ssx0, ssy0, ssx1, ssy1] = startSeg\n  const [smpx, smpy] = getPointBetween(ssx0, ssy0, ssx1, ssy1, 0.5)\n  ;[sx, sy] = getPointBetween(\n    tsx,\n    tsy,\n    smpx,\n    smpy,\n    isColliding ? Math.max(overlapEffect, 0.15) : 0.15\n  )\n\n  arc *= 1 + (Math.max(-2, Math.min(distEffect, 2)) * card - overlapEffect) / 2\n\n  if (isColliding) {\n    arc = arc < 0 ? Math.min(arc, -0.5) : Math.max(arc, 0.5)\n  }\n\n  /* ------------------ ENDING POINT ------------------ */\n\n  if (overlapEffect >= 0.5) {\n    // If overlapping, use the same angle as the start\n    const rayAngle = getAngle(cx0, cy0, smpx, smpy)\n    const [dx1, dy1] = getDelta(rayAngle)\n    ;[[ex, ey]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      dx1,\n      dy1,\n      px1,\n      py1,\n      pw1,\n      ph1,\n      padEnd\n    )\n  } else {\n    // Calculate an angle based on distance, overlap and intermediacy\n    const distOffset1 = modulate(distEffect, [0.75, 1], [0, 1], true)\n\n    const overlapEffect1 = isColliding\n      ? modulate(overlapEffect, [0, 1], [0, PI / 8], true)\n      : 0\n\n    const cardEffect1 = modulate(card * distOffset1, [0, 1], [0, PI / 16], true)\n\n    const combinedOffset =\n      distEffect * (PI / 12) +\n      (cardEffect1 + overlapEffect1) +\n      (distOffset + angleOffset) / 2\n\n    let finalAngle1 =\n      overlapEffect >= 0.5\n        ? angle + PI * rot\n        : angle + PI - Math.max(combinedOffset, MIN_ANGLE) * rot\n\n    // Deltas of ending angle\n    const [dx1, dy1] = getDelta(+(finalAngle1 % PI2).toPrecision(3))\n\n    // Get ray intersection with ending rounded rectangle\n    const [[tex, tey]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      dx1,\n      dy1,\n      px1,\n      py1,\n      pw1,\n      ph1,\n      padEnd\n    )\n\n    // Get midpoint of ending intersected segment\n    const endSeg = getRectangleSegmentIntersectedByRay(\n      px1,\n      py1,\n      pw1,\n      ph1,\n      cx1,\n      cy1,\n      dx1,\n      dy1\n    )\n\n    if (!endSeg) throw Error\n\n    const [sex0, sey0, sex1, sey1] = endSeg\n    const [empx, empy] = getPointBetween(sex0, sey0, sex1, sey1, 0.5)\n\n      // Offset end point toward segment midpoint\n    ;[ex, ey] = getPointBetween(\n      tex,\n      tey,\n      empx,\n      empy,\n      0.25 + overlapEffect * 0.25\n    )\n  }\n\n  /* ------------------- DRAW ARROWS ------------------ */\n\n  // Get midpoints.\n  const [mx1, my1] = getPointBetween(sx, sy, ex, ey, 0.5)\n  const [tix, tiy] = getPointBetween(\n    sx,\n    sy,\n    ex,\n    ey,\n    Math.max(-1, Math.min(1, 0.5 + arc)) // Clamped to 2\n  )\n\n  // Rotate them (these are our two potential corners)\n  const [cixA, ciyA] = rotatePoint(tix, tiy, mx1, my1, (PI / 2) * rot)\n  const [cixB, ciyB] = rotatePoint(tix, tiy, mx1, my1, (PI / 2) * -rot)\n\n  // If we're colliding, pick the furthest corner from the end point.\n  let [cix, ciy] =\n    isColliding &&\n    getDistance(cixA, ciyA, cx1, cy1) < getDistance(cixB, ciyB, cx1, cy1)\n      ? [cixB, ciyB]\n      : [cixA, ciyA]\n\n  // Start and end angles\n  const as = getAngle(cix, ciy, sx, sy)\n  const ae = getAngle(cix, ciy, ex, ey)\n\n  return [sx, sy, cix, ciy, ex, ey, ae, as, getAngle(sx, sy, ex, ey)]\n}\n"],"names":["PI","Math","modulate","value","rangeA","rangeB","clamp","fromLow","fromHigh","toLow","toHigh","result","rotatePoint","x","y","cx","cy","angle","s","sin","c","cos","px","py","nx","ny","getDistance","x0","y0","x1","y1","hypot","getAngle","atan2","projectPoint","a","d","getPointBetween","getSector","floor","getAngliness","abs","doRectanglesCollide","w0","h0","w1","h1","getSegmentCircleIntersections","r","b","u1","u2","ret","retP1","retP2","v1","v2","sqrt","isNaN","length","normalizeAngle","radians","getRaySegmentIntersection","dx","dy","undefined","getDelta","getIntermediate","getLineBetweenRoundedRectangles","r0","r1","cx0","cy0","cx1","cy1","getRayRoundedRectangleIntersection","di0x","di0y","di1x","di1y","ox","oy","w","h","mx","my","rx","ry","mrx","mry","segments","corners","points","forEach","segment","i","px0","py0","px1","py1","as","ae","intersections","getRayCircleIntersection","filter","pt","pointAngle","push","segmentInt","getRectangleSegmentIntersectedByRay","getRectangleSegments","find","sx0","sy0","sx1","sy1","getArrow","options","bow","stretch","stretchMin","stretchMax","padStart","padEnd","flip","straights","dist","angliness","Infinity","includes","ps","max","min","pe","rot","arc","a0","a1","mx1","my1","cx2","cy2","PI2","MIN_ANGLE","getBoxToBoxArrow","sx","sy","ex","ey","pw0","ph0","pw1","ph1","distance","ca","card","isColliding","dix0","diy0","dix1","diy1","distanceBetween","mpdx","mpdy","overlapEffect","distEffect","stretchEffect","angleOffset","distOffset","combinedOffset","finalAngle0","toPrecision","dx0","dy0","tsx","tsy","startSeg","Error","ssx0","ssy0","ssx1","ssy1","smpx","smpy","rayAngle","dx1","dy1","distOffset1","overlapEffect1","cardEffect1","finalAngle1","tex","tey","endSeg","sex0","sey0","sex1","sey1","empx","empy","tix","tiy","cixA","ciyA","cixB","ciyB","cix","ciy"],"mappings":"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"}