{"version":3,"file":"perfect-arrows.cjs.production.min.js","sources":["../src/lib/utils.ts","../src/lib/getBoxToBoxArrow.ts","../src/lib/getArrow.ts"],"sourcesContent":["const PI = Math.PI\n\n/**\n * Modulate a value between two ranges.\n * @param value\n * @param rangeA from [low, high]\n * @param rangeB to [low, high]\n * @param clamp\n */\nexport function modulate(\n  value: number,\n  rangeA: number[],\n  rangeB: number[],\n  clamp = false\n) {\n  const [fromLow, fromHigh] = rangeA\n  const [toLow, toHigh] = rangeB\n  const result =\n    toLow + ((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow)\n  if (clamp === true) {\n    if (toLow < toHigh) {\n      if (result < toLow) {\n        return toLow\n      }\n      if (result > toHigh) {\n        return toHigh\n      }\n    } else {\n      if (result > toLow) {\n        return toLow\n      }\n      if (result < toHigh) {\n        return toHigh\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Rotate a point around a center.\n * @param x The x-axis coordinate of the point.\n * @param y The y-axis coordinate of the point.\n * @param cx The x-axis coordinate of the point to rotate round.\n * @param cy The y-axis coordinate of the point to rotate round.\n * @param angle The distance (in radians) to rotate.\n */\nexport function rotatePoint(\n  x: number,\n  y: number,\n  cx: number,\n  cy: number,\n  angle: number\n) {\n  const s = Math.sin(angle)\n  const c = Math.cos(angle)\n\n  const px = x - cx\n  const py = y - cy\n\n  const nx = px * c - py * s\n  const ny = px * s + py * c\n\n  return [nx + cx, ny + cy]\n}\n\n/**\n * Get the distance between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getDistance(x0: number, y0: number, x1: number, y1: number) {\n  return Math.hypot(y1 - y0, x1 - x0)\n}\n\n/**\n * Get an angle (radians) between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getAngle(x0: number, y0: number, x1: number, y1: number) {\n  return Math.atan2(y1 - y0, x1 - x0)\n}\n\n/**\n * Move a point in an angle by a distance.\n * @param x0\n * @param y0\n * @param a angle (radians)\n * @param d distance\n */\nexport function projectPoint(x0: number, y0: number, a: number, d: number) {\n  return [Math.cos(a) * d + x0, Math.sin(a) * d + y0]\n}\n\n/**\n * Get a point between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n * @param d Normalized\n */\nexport function getPointBetween(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  d = 0.5\n) {\n  return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d]\n}\n\n/**\n * Get the sector of an angle (e.g. quadrant, octant)\n * @param a The angle to check.\n * @param s The number of sectors to check.\n */\nexport function getSector(a: number, s = 8) {\n  return Math.floor(s * (0.5 + ((a / (PI * 2)) % s)))\n}\n\n/**\n * Get a normal value representing how close two points are from being at a 45 degree angle.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n */\nexport function getAngliness(x0: number, y0: number, x1: number, y1: number) {\n  return Math.abs((x1 - x0) / 2 / ((y1 - y0) / 2))\n}\n\n/**\n * Get the points at which an ellipse intersects a rectangle.\n * @param x\n * @param y\n * @param w\n * @param h\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param angle\n */\nexport function getEllipseRectangleIntersectionPoints(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  angle: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getEllipseSegmentIntersections(\n      px0,\n      py0,\n      px1,\n      py1,\n      cx,\n      cy,\n      rx,\n      ry,\n      angle\n    )\n\n    if (ints.length > 0) {\n      points.push(...ints)\n    }\n  }\n\n  points = points.sort(([x0, y0], [x1, y1]) => {\n    return Math.sin(getAngle(cx, cy, x0, y0) - getAngle(cx, cy, x1, y1)) > 0\n      ? -1\n      : 1\n  })\n\n  return points\n}\n\n/**\n * Find the point(s) where a line segment intersects an ellipse.\n * @param x0 The x-axis coordinate of the line's start point.\n * @param y0 The y-axis coordinate of the line's start point.\n * @param x1 The x-axis coordinate of the line's end point.\n * @param y1 The y-axis coordinate of the line's end point.\n * @param cx The x-axis (horizontal) coordinate of the ellipse's center.\n * @param cy The y-axis (vertical) coordinate of the ellipse's center.\n * @param rx The ellipse's major-axis radius. Must be non-negative.\n * @param ry The ellipse's minor-axis radius. Must be non-negative.\n * @param rotation The rotation of the ellipse, expressed in radians.\n * @param segment_only When true, will test the segment as a line (of infinite length).\n */\nexport function getEllipseSegmentIntersections(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  rotation = 0,\n  segment_only = true\n) {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || (x0 === x1 && y0 === y1)) {\n    return []\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points.\n  if (rotation !== 0) {\n    ;[x0, y0] = rotatePoint(x0, y0, cx, cy, -rotation)\n    ;[x1, y1] = rotatePoint(x1, y1, cx, cy, -rotation)\n  }\n\n  // Translate so the ellipse is centered at the origin.\n  x0 -= cx\n  y0 -= cy\n  x1 -= cx\n  y1 -= cy\n\n  // Calculate the quadratic parameters.\n  var A = ((x1 - x0) * (x1 - x0)) / rx / rx + ((y1 - y0) * (y1 - y0)) / ry / ry\n  var B = (2 * x0 * (x1 - x0)) / rx / rx + (2 * y0 * (y1 - y0)) / ry / ry\n  var C = (x0 * x0) / rx / rx + (y0 * y0) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  var tValues: number[] = []\n\n  // Calculate the discriminant.\n  var discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    // Two real solutions.\n    tValues.push((-B + Math.sqrt(discriminant)) / 2 / A)\n    tValues.push((-B - Math.sqrt(discriminant)) / 2 / A)\n  }\n\n  return (\n    tValues\n      // Filter to only points that are on the segment.\n      .filter(t => !segment_only || (t >= 0 && t <= 1))\n      // Solve for points.\n      .map(t => [x0 + (x1 - x0) * t + cx, y0 + (y1 - y0) * t + cy])\n      // Counter-rotate points\n      .map(p =>\n        rotation === 0 ? p : rotatePoint(p[0], p[1], cx, cy, rotation)\n      )\n  )\n}\n\n/**\n * Check whether two rectangles will collide (overlap).\n * @param x0 The x-axis coordinate of the first rectangle.\n * @param y0 The y-axis coordinate of the first rectangle.\n * @param w0 The width of the first rectangle.\n * @param h0 The height of the first rectangle.\n * @param x1 The x-axis coordinate of the second rectangle.\n * @param y1 The y-axis coordinate of the second rectangle.\n * @param w1 The width of the second rectangle.\n * @param h1 The height of the second rectangle.\n */\nexport function doRectanglesCollide(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number\n) {\n  return !(x0 >= x1 + w1 || x1 >= x0 + w0 || y0 >= y1 + h1 || y1 >= y0 + h0)\n}\n\n/**\n * Find the point(s) where a segment intersects a rectangle.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of the segment's starting point.\n * @param x1 The x-axis coordinate of the segment's ending point.\n * @param y1 The y-axis coordinate of the segment's ending point.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n */\nexport function getSegmentRectangleIntersectionPoints(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getSegmentSegmentIntersection(\n      px0,\n      py0,\n      px1,\n      py1,\n      x0,\n      y0,\n      x1,\n      y1\n    )\n    if (ints) {\n      points.push(ints)\n    }\n  }\n\n  return points\n}\n\n/**\n * Find the point, if any, where two segments intersect.\n * @param x0 The x-axis coordinate of the first segment's starting point.\n * @param y0 The y-axis coordinate of the first segment's starting point.\n * @param x1 The x-axis coordinate of the first segment's ending point.\n * @param y1 The y-axis coordinate of the first segment's ending point.\n * @param x2 The x-axis coordinate of the second segment's starting point.\n * @param y2 The y-axis coordinate of the second segment's starting point.\n * @param x3 The x-axis coordinate of the second segment's ending point.\n * @param y3 The y-axis coordinate of the second segment's ending point.\n */\nexport function getSegmentSegmentIntersection(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number\n) {\n  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0)\n  const numeA = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2)\n  const numeB = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2)\n\n  if (denom === 0) {\n    if (numeA === 0 && numeB === 0) {\n      return undefined // Colinear\n    }\n    return undefined // Parallel\n  }\n\n  const uA = numeA / denom\n  const uB = numeB / denom\n\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    return [x0 + uA * (x1 - x0), y0 + uA * (y1 - y0)]\n  }\n\n  return undefined // No intersection\n}\n\n/**\n * Get the intersection points between a line segment and a rectangle with rounded corners.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of the segment's ending point.\n * @param x1 The delta-x of the ray.\n * @param y1 The delta-y of the ray.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n * @param r The corner radius of the rectangle.\n */\nexport function getSegmentRoundedRectangleIntersectionPoints(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const mx = x + w,\n    my = y + h,\n    rx = x + r,\n    ry = y + r,\n    mrx = x + w - r,\n    mry = y + h - r\n\n  const segments = [\n    [x, mry, x, ry, x, y],\n    [rx, y, mrx, y, mx, y],\n    [mx, ry, mx, mry, mx, my],\n    [mrx, my, rx, my, x, my],\n  ]\n\n  const corners = [\n    [rx, ry, PI, PI * 1.5],\n    [mrx, ry, PI * 1.5, PI * 2],\n    [mrx, mry, 0, PI * 0.5],\n    [rx, mry, PI * 0.5, PI],\n  ]\n\n  let points: number[][] = []\n\n  segments.forEach((segment, i) => {\n    const [px0, py0, px1, py1] = segment\n    const [cx, cy, as, ae] = corners[i]\n\n    getSegmentCircleIntersections(cx, cy, r, x0, y0, x1, y1)\n      .filter(pt => {\n        const pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]))\n        return pointAngle > as && pointAngle < ae\n      })\n      .forEach(pt => points.push(pt))\n\n    const segmentInt = getSegmentSegmentIntersection(\n      x0,\n      y0,\n      x1,\n      y1,\n      px0,\n      py0,\n      px1,\n      py1\n    )\n\n    if (!!segmentInt) {\n      points.push(segmentInt)\n    }\n  })\n\n  return points\n}\n\n/**\n * Get the point(s) where a line segment intersects a circle.\n * @param cx The x-axis coordinate of the circle's center.\n * @param cy The y-axis coordinate of the circle's center.\n * @param r The circle's radius.\n * @param x0 The x-axis coordinate of the segment's starting point.\n * @param y0 The y-axis coordinate of ththe segment's ending point.\n * @param x1 The delta-x of the ray.\n * @param y1 The delta-y of the ray.\n */\nexport function getSegmentCircleIntersections(\n  cx: number,\n  cy: number,\n  r: number,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) {\n  var b: number,\n    c: number,\n    d: number,\n    u1: number,\n    u2: number,\n    ret: number[][],\n    retP1: number[],\n    retP2: number[],\n    v1 = [x1 - x0, y1 - y0],\n    v2 = [x0 - cx, y0 - cy]\n\n  b = v1[0] * v2[0] + v1[1] * v2[1]\n  c = 2 * (v1[0] * v1[0] + v1[1] * v1[1])\n  b *= -2\n  d = Math.sqrt(b * b - 2 * c * (v2[0] * v2[0] + v2[1] * v2[1] - r * r))\n  if (isNaN(d)) {\n    // no intercept\n    return []\n  }\n  u1 = (b - d) / c // these represent the unit distance of point one and two on the line\n  u2 = (b + d) / c\n  retP1 = [] // return points\n  retP2 = []\n  ret = [] // return array\n\n  if (u1 <= 1 && u1 >= 0) {\n    // add point if on the line segment\n    retP1[0] = x0 + v1[0] * u1\n    retP1[1] = y0 + v1[1] * u1\n    ret[0] = retP1\n  }\n\n  if (u2 <= 1 && u2 >= 0) {\n    // second add point if on the line segment\n    retP2[0] = x0 + v1[0] * u2\n    retP2[1] = y0 + v1[1] * u2\n    ret[ret.length] = retP2\n  }\n\n  return ret\n}\n\n/**\n * Normalize an angle (in radians)\n * @param radians The radians quantity to normalize.\n */\nexport function normalizeAngle(radians: number) {\n  return radians - PI * 2 * Math.floor(radians / (PI * 2))\n}\n\n/**\n *\n * @param x The x-axis coordinate of the ray's origin.\n * @param y The y-axis coordinate of the ray's origin.\n * @param w\n * @param h\n * @param x0\n * @param y0\n * @param x1\n * @param y1\n */\nexport function getRayRectangleIntersectionPoints(\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  let points: number[][] = []\n\n  for (let [px0, py0, px1, py1] of [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]) {\n    const ints = getRaySegmentIntersection(ox, oy, dx, dy, px0, py0, px1, py1)\n    if (ints) {\n      points.push(ints)\n    }\n  }\n\n  return points\n}\n\n/**\n * Get the point at which a ray intersects a segment.\n * @param x The x-axis coordinate of the ray's origin.\n * @param y The y-axis coordinate of the ray's origin.\n * @param dx The x-axis delta of the angle.\n * @param dy The y-axis delta of the angle.\n * @param x0 The x-axis coordinate of the segment's start point.\n * @param y0 The y-axis coordinate of the segment's start point.\n * @param x1 The x-axis coordinate of the segment's end point.\n * @param y1 The y-axis coordinate of the segment's end point.\n */\nexport function getRaySegmentIntersection(\n  x: number,\n  y: number,\n  dx: number,\n  dy: number,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) {\n  let r: number, s: number, d: number\n\n  if (dy * (x1 - x0) !== dx * (y1 - y0)) {\n    d = dx * (y1 - y0) - dy * (x1 - x0)\n    if (d !== 0) {\n      r = ((y - y0) * (x1 - x0) - (x - x0) * (y1 - y0)) / d\n      s = ((y - y0) * dx - (x - x0) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return [x + r * dx, y + r * dy]\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * Get the normalized delta (x and y) for an angle.\n * @param angle The angle in radians\n */\nexport function getDelta(angle: number) {\n  return [Math.cos(angle), Math.sin(angle)]\n}\n\nexport function getIntermediate(angle: number) {\n  return Math.abs(Math.abs(angle % (PI / 2)) - PI / 4) / (PI / 4)\n}\n\n/**\n * Get a line between two rounded rectangles.\n * @param x0\n * @param y0\n * @param w0\n * @param h0\n * @param r0\n * @param x1\n * @param y1\n * @param w1\n * @param h1\n * @param r1\n */\nexport function getLineBetweenRoundedRectangles(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  r0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  r1: number\n) {\n  const cx0 = x0 + w0 / 2,\n    cy0 = y0 + h0 / 2,\n    cx1 = x1 + w1 / 2,\n    cy1 = y1 + h1 / 2,\n    [[di0x, di0y]] = getRayRoundedRectangleIntersection(\n      cx0,\n      cy0,\n      cx1 - cx0,\n      cy1 - cy0,\n      x0,\n      y0,\n      w0,\n      h0,\n      r0\n    ) || [[cx0, cy0]],\n    [[di1x, di1y]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      cx0 - cx1,\n      cy0 - cy1,\n      x1,\n      y1,\n      w1,\n      h1,\n      r1\n    ) || [[cx1, cy1]]\n\n  return [di0x, di0y, di1x, di1y]\n}\n\n/**\n * Get the intersection points between a ray and a rectangle with rounded corners.\n * @param ox The x-axis coordinate of the ray's origin.\n * @param oy The y-axis coordinate of the ray's origin.\n * @param dx The delta-x of the ray.\n * @param dy The delta-y of the ray.\n * @param x The x-axis coordinate of the rectangle.\n * @param y The y-axis coordinate of the rectangle.\n * @param w The width of the rectangle.\n * @param h The height of the rectangle.\n * @param r The corner radius of the rectangle.\n */\nexport function getRayRoundedRectangleIntersection(\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const mx = x + w,\n    my = y + h,\n    rx = x + r - 1,\n    ry = y + r - 1,\n    mrx = x + w - r + 1,\n    mry = y + h - r + 1\n\n  const segments = [\n    [x, mry, x, ry],\n    [rx, y, mrx, y],\n    [mx, ry, mx, mry],\n    [mrx, my, rx, my],\n  ]\n\n  const corners = [\n    [rx, ry, Math.PI, Math.PI * 1.5],\n    [mrx, ry, Math.PI * 1.5, Math.PI * 2],\n    [mrx, mry, 0, Math.PI * 0.5],\n    [rx, mry, Math.PI * 0.5, Math.PI],\n  ]\n\n  let points: number[][] = []\n\n  segments.forEach((segment, i) => {\n    const [px0, py0, px1, py1] = segment\n    const [cx, cy, as, ae] = corners[i]\n\n    const intersections = getRayCircleIntersection(cx, cy, r, ox, oy, dx, dy)\n\n    intersections &&\n      intersections\n        .filter(pt => {\n          const pointAngle = normalizeAngle(getAngle(cx, cy, pt[0], pt[1]))\n          return pointAngle > as && pointAngle < ae\n        })\n        .forEach(pt => points.push(pt))\n\n    const segmentInt = getRaySegmentIntersection(\n      ox,\n      oy,\n      dx,\n      dy,\n      px0,\n      py0,\n      px1,\n      py1\n    )\n\n    if (!!segmentInt) {\n      points.push(segmentInt)\n    }\n  })\n\n  return points\n}\n\nexport function getRectangleSegmentIntersectedByRay(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number\n) {\n  return getRectangleSegments(x, y, w, h).find(([sx0, sy0, sx1, sy1]) =>\n    getRaySegmentIntersection(ox, oy, dx, dy, sx0, sy0, sx1, sy1)\n  )\n}\n\nexport function getRectangleSegments(\n  x: number,\n  y: number,\n  w: number,\n  h: number\n) {\n  return [\n    [x, y, x + w, y],\n    [x + w, y, x + w, y + h],\n    [x + w, y + h, x, y + h],\n    [x, y + h, x, y],\n  ]\n}\n\nexport function getRoundedRectangleSegments(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  r: number\n) {\n  const rx = x + r,\n    ry = y + r,\n    mx = x + w,\n    my = y + h,\n    mrx = x + w - r,\n    mry = y + h - r\n\n  return [\n    [x, mry, x, ry, x, y],\n    [rx, y, mrx, y, mx, y],\n    [mx, ry, mx, mry, mx, my],\n    [mrx, my, rx, my, x, my],\n  ]\n}\n\nexport function getRayCircleIntersection(\n  cx: number,\n  cy: number,\n  r: number,\n  ox: number,\n  oy: number,\n  dx: number,\n  dy: number\n) {\n  // This is a shitty hack\n  return getSegmentCircleIntersections(\n    cx,\n    cy,\n    r,\n    ox,\n    oy,\n    dx * 999999,\n    dy * 999999\n  )\n}\n","import {\n  getDistance,\n  getSector,\n  modulate,\n  getDelta,\n  getAngle,\n  rotatePoint,\n  getPointBetween,\n  doRectanglesCollide,\n  getIntermediate,\n  getLineBetweenRoundedRectangles,\n  normalizeAngle,\n  getRayRoundedRectangleIntersection,\n  getRectangleSegmentIntersectedByRay,\n} from \"./utils\"\n\nexport type ArrowOptions = {\n  bow?: number\n  stretchMin?: number\n  stretchMax?: number\n  stretch?: number\n  padStart?: number\n  padEnd?: number\n  flip?: boolean\n  straights?: boolean\n}\n\nconst PI = Math.PI\nconst PI2 = PI * 2\nconst MIN_ANGLE = PI / 24\n\n/**\n * getArrowBetweenBoxes\n * Get the points for a linking line between two boxes.\n * @param x0 The x-axis coordinate of the first box.\n * @param y0 The y-axis coordinate of the first box.\n * @param w0 The width of the first box.\n * @param h0 The height of the first box.\n * @param x1 The x-axis coordinate of the second box.\n * @param y1 The y-axis coordinate of the second box.\n * @param w1 The width of the second box.\n * @param h1 The height of the second box.\n * @param options\n */\nexport default function getBoxToBoxArrow(\n  x0: number,\n  y0: number,\n  w0: number,\n  h0: number,\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  options: ArrowOptions = {} as ArrowOptions\n) {\n  let sx: number, sy: number, ex: number, ey: number\n\n  const {\n    bow = 0,\n    stretch = 0.25,\n    stretchMin = 50,\n    stretchMax = 420,\n    padStart = 0,\n    padEnd = 20,\n    flip = false,\n    straights = true,\n  } = options\n\n  const px0 = x0 - padStart,\n    py0 = y0 - padStart,\n    pw0 = w0 + padStart * 2,\n    ph0 = h0 + padStart * 2,\n    px1 = x1 - padEnd,\n    py1 = y1 - padEnd,\n    pw1 = w1 + padEnd * 2,\n    ph1 = h1 + padEnd * 2,\n    cx0 = x0 + w0 / 2,\n    cy0 = y0 + h0 / 2,\n    cx1 = x1 + w1 / 2,\n    cy1 = y1 + h1 / 2\n\n  // Angle between centers\n  const angle = normalizeAngle(getAngle(cx0, cy0, cx1, cy1))\n\n  // Distance between centers\n  const distance = getDistance(cx0, cy0, cx1, cy1)\n\n  // Perfect overlap, no arrow.\n  if (distance === 0) {\n    const [sx, sy] = [cx0, py0]\n    const [ex, ey] = [cx1, py1]\n    const [cx, cy] = getPointBetween(sx, sy, ex, ey, 0.5)\n    const ca = getAngle(sx, sy, ex, ey)\n    return [sx, sy, cx, cy, ex, ey, ca, ca, ca]\n  }\n\n  // Rotation of the arrow, clockwise or anticlockwise\n  const rot = (getSector(angle) % 2 === 0 ? -1 : 1) * (flip ? -1 : 1)\n\n  // How cardinal is the angle? 0 = 45deg, 1 = 90deg\n  let card = getIntermediate(angle)\n\n  if (card < 1 && card > 0.85) card = 0.99\n\n  // Are the boxes colliding / overlapping?\n  const isColliding = doRectanglesCollide(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    px1,\n    py1,\n    pw1,\n    ph1\n  )\n\n  // Direct line between boxes\n  const [dix0, diy0, dix1, diy1] = getLineBetweenRoundedRectangles(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    padStart,\n    px1,\n    py1,\n    pw1,\n    ph1,\n    padEnd\n  )\n\n  // Length of the direct line between boxes\n  const distanceBetween = getDistance(dix0, diy0, dix1, diy1)\n\n  /* ------------- RETURN A STRAIGHT ARROW ------------ */\n\n  // Should we just draw a straight line?\n  if (!isColliding && straights && card % 0.5 === 0) {\n    const [mpdx, mpdy] = getPointBetween(dix0, diy0, dix1, diy1, 0.5)\n    return [dix0, diy0, mpdx, mpdy, dix1, diy1, angle, angle - PI, angle]\n  }\n\n  /* -------------- RETURN A CURVED ARROW ------------- */\n\n  // How much are the two boxes overlapping?\n  let overlapEffect = isColliding\n    ? modulate(distanceBetween, [0, distance], [0, 1], true)\n    : 0\n\n  // How far away are the two boxes?\n  const distEffect = 1 - distanceBetween / distance\n\n  // How much should the stretch impact the arc?\n  const stretchEffect = modulate(\n    distanceBetween,\n    [stretchMin, stretchMax],\n    [1, 0],\n    true\n  )\n\n  // What should the curved line's arc be?\n  let arc = bow + stretchEffect * stretch\n\n  // How much should the angle's intermediacy (45degree-ness) affect the angle?\n  let angleOffset = modulate(\n    card * card, // a better curve here?\n    [0, 1],\n    [PI * 0.125, 0],\n    true\n  )\n\n  const distOffset = isColliding\n    ? PI * 0.5 * card\n    : modulate(\n        distEffect, // a better curve here?\n        [0.75, 1],\n        [0, PI * 0.5],\n        true\n      ) * card\n\n  const combinedOffset =\n    distOffset + angleOffset * (isColliding ? 1 - overlapEffect : 1)\n\n  /* ----------------- STARTING POINT ----------------- */\n\n  // Angle of the first box\n  let finalAngle0 =\n    overlapEffect >= 0.5\n      ? angle + PI * rot\n      : angle + Math.max(MIN_ANGLE, combinedOffset) * rot\n\n  // Deltas of starting angle\n  const [dx0, dy0] = getDelta(+(finalAngle0 % PI2).toPrecision(3))\n\n  // Get ray intersection with rounded rectangle\n  const [[tsx, tsy]] = getRayRoundedRectangleIntersection(\n    cx0,\n    cy0,\n    dx0,\n    dy0,\n    px0,\n    py0,\n    pw0,\n    ph0,\n    padStart\n  )\n\n  // Get midpoint of startingintersected segment\n  const startSeg = getRectangleSegmentIntersectedByRay(\n    px0,\n    py0,\n    pw0,\n    ph0,\n    cx0,\n    cy0,\n    dx0,\n    dy0\n  )\n\n  if (!startSeg) throw Error\n\n  // Find start point (quarter way between segment midpoint and ray intersection)\n  const [ssx0, ssy0, ssx1, ssy1] = startSeg\n  const [smpx, smpy] = getPointBetween(ssx0, ssy0, ssx1, ssy1, 0.5)\n  ;[sx, sy] = getPointBetween(\n    tsx,\n    tsy,\n    smpx,\n    smpy,\n    isColliding ? Math.max(overlapEffect, 0.15) : 0.15\n  )\n\n  arc *= 1 + (Math.max(-2, Math.min(distEffect, 2)) * card - overlapEffect) / 2\n\n  if (isColliding) {\n    arc = arc < 0 ? Math.min(arc, -0.5) : Math.max(arc, 0.5)\n  }\n\n  /* ------------------ ENDING POINT ------------------ */\n\n  if (overlapEffect >= 0.5) {\n    // If overlapping, use the same angle as the start\n    const rayAngle = getAngle(cx0, cy0, smpx, smpy)\n    const [dx1, dy1] = getDelta(rayAngle)\n    ;[[ex, ey]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      dx1,\n      dy1,\n      px1,\n      py1,\n      pw1,\n      ph1,\n      padEnd\n    )\n  } else {\n    // Calculate an angle based on distance, overlap and intermediacy\n    const distOffset1 = modulate(distEffect, [0.75, 1], [0, 1], true)\n\n    const overlapEffect1 = isColliding\n      ? modulate(overlapEffect, [0, 1], [0, PI / 8], true)\n      : 0\n\n    const cardEffect1 = modulate(card * distOffset1, [0, 1], [0, PI / 16], true)\n\n    const combinedOffset =\n      distEffect * (PI / 12) +\n      (cardEffect1 + overlapEffect1) +\n      (distOffset + angleOffset) / 2\n\n    let finalAngle1 =\n      overlapEffect >= 0.5\n        ? angle + PI * rot\n        : angle + PI - Math.max(combinedOffset, MIN_ANGLE) * rot\n\n    // Deltas of ending angle\n    const [dx1, dy1] = getDelta(+(finalAngle1 % PI2).toPrecision(3))\n\n    // Get ray intersection with ending rounded rectangle\n    const [[tex, tey]] = getRayRoundedRectangleIntersection(\n      cx1,\n      cy1,\n      dx1,\n      dy1,\n      px1,\n      py1,\n      pw1,\n      ph1,\n      padEnd\n    )\n\n    // Get midpoint of ending intersected segment\n    const endSeg = getRectangleSegmentIntersectedByRay(\n      px1,\n      py1,\n      pw1,\n      ph1,\n      cx1,\n      cy1,\n      dx1,\n      dy1\n    )\n\n    if (!endSeg) throw Error\n\n    const [sex0, sey0, sex1, sey1] = endSeg\n    const [empx, empy] = getPointBetween(sex0, sey0, sex1, sey1, 0.5)\n\n      // Offset end point toward segment midpoint\n    ;[ex, ey] = getPointBetween(\n      tex,\n      tey,\n      empx,\n      empy,\n      0.25 + overlapEffect * 0.25\n    )\n  }\n\n  /* ------------------- DRAW ARROWS ------------------ */\n\n  // Get midpoints.\n  const [mx1, my1] = getPointBetween(sx, sy, ex, ey, 0.5)\n  const [tix, tiy] = getPointBetween(\n    sx,\n    sy,\n    ex,\n    ey,\n    Math.max(-1, Math.min(1, 0.5 + arc)) // Clamped to 2\n  )\n\n  // Rotate them (these are our two potential corners)\n  const [cixA, ciyA] = rotatePoint(tix, tiy, mx1, my1, (PI / 2) * rot)\n  const [cixB, ciyB] = rotatePoint(tix, tiy, mx1, my1, (PI / 2) * -rot)\n\n  // If we're colliding, pick the furthest corner from the end point.\n  let [cix, ciy] =\n    isColliding &&\n    getDistance(cixA, ciyA, cx1, cy1) < getDistance(cixB, ciyB, cx1, cy1)\n      ? [cixB, ciyB]\n      : [cixA, ciyA]\n\n  // Start and end angles\n  const as = getAngle(cix, ciy, sx, sy)\n  const ae = getAngle(cix, ciy, ex, ey)\n\n  return [sx, sy, cix, ciy, ex, ey, ae, as, getAngle(sx, sy, ex, ey)]\n}\n","import {\n  getAngle,\n  getDistance,\n  getAngliness,\n  projectPoint,\n  getPointBetween,\n  getSector,\n  rotatePoint,\n  modulate,\n} from \"./utils\"\n\nexport type ArrowOptions = {\n  bow?: number\n  stretchMin?: number\n  stretchMax?: number\n  stretch?: number\n  padStart?: number\n  padEnd?: number\n  flip?: boolean\n  straights?: boolean\n}\n\n/**\n * getArrow\n * Get the points for a linking line between two points.\n * @description Draw an arrow between two points.\n * @param x0 The x position of the \"from\" point.\n * @param y0 The y position of the \"from\" point.\n * @param x1 The x position of the \"to\" point.\n * @param y1 The y position of the \"to\" point.\n * @param options Additional options for computing the line.\n * @returns [sx, sy, cx, cy, e1, e2, ae, as, ac]\n * @example\n * const arrow = getArrow(0, 0, 100, 200, {\n    bow: 0\n    stretch: .5\n    stretchMin: 0\n    stretchMax: 420\n    padStart: 0\n    padEnd: 0\n    flip: false\n    straights: true\n * })\n * \n * const [\n *  startX, startY, \n *  controlX, controlY, \n *  endX, endY, \n *  endAngle, \n *  startAngle,\n *  controlAngle\n *  ] = arrow\n */\nexport default function getArrow(\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number,\n  options: ArrowOptions = {} as ArrowOptions\n): number[] {\n  const {\n    bow = 0,\n    stretch = 0.5,\n    stretchMin = 0,\n    stretchMax = 420,\n    padStart = 0,\n    padEnd = 0,\n    flip = false,\n    straights = true,\n  } = options\n\n  const angle = getAngle(x0, y0, x1, y1)\n  const dist = getDistance(x0, y0, x1, y1)\n  const angliness = getAngliness(x0, y0, x1, y1)\n\n  // Step 0 ⤜⤏ Should the arrow be straight?\n\n  if (\n    dist < (padStart + padEnd) * 2 || // Too short\n    (bow === 0 && stretch === 0) || // No bow, no stretch\n    (straights && [0, 1, Infinity].includes(angliness)) // 45 degree angle\n  ) {\n    // ⤜⤏ Arrow is straight! Just pad start and end points.\n\n    // Padding distances\n    const ps = Math.max(0, Math.min(dist - padStart, padStart))\n    const pe = Math.max(0, Math.min(dist - ps, padEnd))\n\n    // Move start point toward end point\n    let [px0, py0] = projectPoint(x0, y0, angle, ps)\n\n    // Move end point toward start point\n    let [px1, py1] = projectPoint(x1, y1, angle + Math.PI, pe)\n\n    // Get midpoint between new points\n    const [mx, my] = getPointBetween(px0, py0, px1, py1, 0.5)\n\n    return [px0, py0, mx, my, px1, py1, angle, angle, angle]\n  }\n\n  // ⤜⤏ Arrow is an arc!\n\n  // Is the arc clockwise or counterclockwise?\n  let rot = (getSector(angle) % 2 === 0 ? 1 : -1) * (flip ? -1 : 1)\n\n  // Calculate how much the line should \"bow\" away from center\n  const arc =\n    bow + modulate(dist, [stretchMin, stretchMax], [1, 0], true) * stretch\n\n  // Step 1 ⤜⤏ Find padded points.\n\n  // Get midpoint.\n  const [mx, my] = getPointBetween(x0, y0, x1, y1, 0.5)\n\n  // Get control point.\n  let [cx, cy] = getPointBetween(x0, y0, x1, y1, 0.5 - arc)\n\n    // Rotate control point (clockwise or counterclockwise).\n  ;[cx, cy] = rotatePoint(cx, cy, mx, my, (Math.PI / 2) * rot)\n\n  // Get padded start point.\n  const a0 = getAngle(x0, y0, cx, cy)\n  const [px0, py0] = projectPoint(x0, y0, a0, padStart)\n\n  // Get padded end point.\n  const a1 = getAngle(x1, y1, cx, cy)\n  const [px1, py1] = projectPoint(x1, y1, a1, padEnd)\n\n  // Step 2  ⤜⤏ Find start and end angles.\n\n  // Start angle\n  const as = getAngle(cx, cy, x0, y0)\n\n  // End angle\n  const ae = getAngle(cx, cy, x1, y1)\n\n  // Step 3 ⤜⤏ Find control point for padded points.\n\n  // Get midpoint between padded start / end points.\n  const [mx1, my1] = getPointBetween(px0, py0, px1, py1, 0.5)\n\n  // Get control point for padded start / end points.\n  let [cx1, cy1] = getPointBetween(px0, py0, px1, py1, 0.5 - arc)\n\n    // Rotate control point (clockwise or counterclockwise).\n  ;[cx1, cy1] = rotatePoint(cx1, cy1, mx1, my1, (Math.PI / 2) * rot)\n\n  // Finally, average the two control points.\n  let [cx2, cy2] = getPointBetween(cx, cy, cx1, cy1, 0.5)\n\n  return [px0, py0, cx2, cy2, px1, py1, ae, as, angle]\n}\n"],"names":["PI","Math","modulate","value","rangeA","rangeB","clamp","fromLow","toLow","toHigh","result","rotatePoint","x","y","cx","cy","angle","s","sin","c","cos","px","py","getDistance","x0","y0","x1","y1","hypot","getAngle","atan2","projectPoint","a","d","getPointBetween","getSector","floor","normalizeAngle","radians","getRaySegmentIntersection","dx","dy","r","getDelta","getRayRoundedRectangleIntersection","ox","oy","w","h","mx","my","rx","ry","mrx","mry","corners","points","forEach","segment","i","px0","py0","px1","py1","as","ae","intersections","b","u1","u2","ret","retP1","retP2","v1","v2","sqrt","isNaN","length","getSegmentCircleIntersections","getRayCircleIntersection","filter","pt","pointAngle","push","segmentInt","getRectangleSegmentIntersectedByRay","getRectangleSegments","find","PI2","MIN_ANGLE","options","bow","stretch","stretchMin","stretchMax","padStart","padEnd","flip","straights","dist","angliness","abs","getAngliness","Infinity","includes","ps","max","min","pe","rot","arc","mx1","my1","cx1","cy1","w0","h0","w1","h1","sx","sy","ex","ey","pw0","ph0","pw1","ph1","cx0","cy0","distance","ca","card","getIntermediate","isColliding","doRectanglesCollide","r0","r1","di0x","di0y","getLineBetweenRoundedRectangles","dix0","diy0","dix1","diy1","distanceBetween","overlapEffect","distEffect","angleOffset","distOffset","toPrecision","dx0","dy0","tsx","tsy","startSeg","Error","smpx","smpy","distOffset1","overlapEffect1","cardEffect1","dx1","dy1","tex","tey","endSeg","tix","tiy","cixA","ciyA","cixB","ciyB","cix","ciy"],"mappings":"oEAAA,IAAMA,EAAKC,KAAKD,YASAE,EACdC,EACAC,EACAC,EACAC,YAAAA,IAAAA,GAAQ,OAEDC,EAAqBH,KACrBI,EAAiBH,KAAVI,EAAUJ,KAClBK,EACJF,GAAUL,EAAQI,IAHQH,KAGeG,IAAaE,EAASD,OACnD,IAAVF,KACEE,EAAQC,EAAQ,IACdC,EAASF,SACJA,KAELE,EAASD,SACJA,MAEJ,IACDC,EAASF,SACJA,KAELE,EAASD,SACJA,SAINC,WAWOC,EACdC,EACAC,EACAC,EACAC,EACAC,OAEMC,EAAIhB,KAAKiB,IAAIF,GACbG,EAAIlB,KAAKmB,IAAIJ,GAEbK,EAAKT,EAAIE,EACTQ,EAAKT,EAAIE,QAKR,CAHIM,EAAKF,EAAIG,EAAKL,EAGZH,EAFFO,EAAKJ,EAAIK,EAAKH,EAEHJ,YAURQ,EAAYC,EAAYC,EAAYC,EAAYC,UACvD1B,KAAK2B,MAAMD,EAAKF,EAAIC,EAAKF,YAUlBK,EAASL,EAAYC,EAAYC,EAAYC,UACpD1B,KAAK6B,MAAMH,EAAKF,EAAIC,EAAKF,YAUlBO,EAAaP,EAAYC,EAAYO,EAAWC,SACvD,CAAChC,KAAKmB,IAAIY,GAAKC,EAAIT,EAAIvB,KAAKiB,IAAIc,GAAKC,EAAIR,YAWlCS,EACdV,EACAC,EACAC,EACAC,EACAM,mBAAAA,IAAAA,EAAI,IAEG,CAACT,GAAME,EAAKF,GAAMS,EAAGR,GAAME,EAAKF,GAAMQ,YAQ/BE,EAAUH,EAAWf,mBAAAA,IAAAA,EAAI,GAChChB,KAAKmC,MAAMnB,GAAK,GAAQe,GAAU,EAALhC,GAAWiB,aAoZjCoB,EAAeC,UACtBA,EAAe,EAALtC,EAASC,KAAKmC,MAAME,GAAgB,EAALtC,aAoDlCuC,EACd3B,EACAC,EACA2B,EACAC,EACAjB,EACAC,EACAC,EACAC,OAEIe,EAAWzB,EAAWgB,KAEtBQ,GAAMf,EAAKF,IAAQgB,GAAMb,EAAKF,IAEtB,IADVQ,EAAIO,GAAMb,EAAKF,GAAMgB,GAAMf,EAAKF,MAG9BP,IAAMJ,EAAIY,GAAMe,GAAM5B,EAAIY,GAAMiB,GAAMR,GADtCS,IAAM7B,EAAIY,IAAOC,EAAKF,IAAOZ,EAAIY,IAAOG,EAAKF,IAAOQ,IAE3C,GAAKhB,GAAK,GAAKA,GAAK,SACpB,CAACL,EAAI8B,EAAIF,EAAI3B,EAAI6B,EAAID,YAWpBE,EAAS3B,SAChB,CAACf,KAAKmB,IAAIJ,GAAQf,KAAKiB,IAAIF,aA0EpB4B,EACdC,EACAC,EACAN,EACAC,EACA7B,EACAC,EACAkC,EACAC,EACAN,OAEMO,EAAKrC,EAAImC,EACbG,EAAKrC,EAAImC,EACTG,EAAKvC,EAAI8B,EAAI,EACbU,EAAKvC,EAAI6B,EAAI,EACbW,EAAMzC,EAAImC,EAAIL,EAAI,EAClBY,EAAMzC,EAAImC,EAAIN,EAAI,EASda,EAAU,CACd,CAACJ,EAAIC,EAAInD,KAAKD,GAAc,IAAVC,KAAKD,IACvB,CAACqD,EAAKD,EAAc,IAAVnD,KAAKD,GAAoB,EAAVC,KAAKD,IAC9B,CAACqD,EAAKC,EAAK,EAAa,GAAVrD,KAAKD,IACnB,CAACmD,EAAIG,EAAe,GAAVrD,KAAKD,GAAUC,KAAKD,KAG5BwD,EAAqB,SAdR,CACf,CAAC5C,EAAG0C,EAAK1C,EAAGwC,GACZ,CAACD,EAAItC,EAAGwC,EAAKxC,GACb,CAACoC,EAAIG,EAAIH,EAAIK,GACb,CAACD,EAAKH,EAAIC,EAAID,IAYPO,SAAQ,SAACC,EAASC,OAClBC,EAAsBF,KAAjBG,EAAiBH,KAAZI,EAAYJ,KAAPK,EAAOL,OACJH,EAAQI,GAA1B7C,OAAIC,OAAIiD,OAAIC,OAEbC,WAiFRpD,EACAC,EACA2B,EACAG,EACAC,EACAN,EACAC,mBAhVA3B,EACAC,EACA2B,EACAlB,EACAC,EACAC,EACAC,OAEIwC,EACFhD,EACAc,EACAmC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAK,CAAC/C,EAAKF,EAAIG,EAAKF,GACpBiD,EAAK,CAAClD,EAAKV,EAAIW,EAAKV,UAEtBoD,EAAIM,EAAG,GAAKC,EAAG,GAAKD,EAAG,GAAKC,EAAG,GAC/BvD,EAAI,GAAKsD,EAAG,GAAKA,EAAG,GAAKA,EAAG,GAAKA,EAAG,IACpCN,IAAM,EACNlC,EAAIhC,KAAK0E,KAAKR,EAAIA,EAAI,EAAIhD,GAAKuD,EAAG,GAAKA,EAAG,GAAKA,EAAG,GAAKA,EAAG,GAAKhC,EAAIA,IAC/DkC,MAAM3C,GAED,IAGToC,GAAMF,EAAIlC,GAAKd,EACfoD,EAAQ,GACRC,EAAQ,GACRF,EAAM,IAJNF,GAAMD,EAAIlC,GAAKd,IAML,GAAKiD,GAAM,IAEnBG,EAAM,GAAK/C,EAAKiD,EAAG,GAAKL,EACxBG,EAAM,GAAK9C,EAAKgD,EAAG,GAAKL,EACxBE,EAAI,GAAKC,GAGPF,GAAM,GAAKA,GAAM,IAEnBG,EAAM,GAAKhD,EAAKiD,EAAG,GAAKJ,EACxBG,EAAM,GAAK/C,EAAKgD,EAAG,GAAKJ,EACxBC,EAAIA,EAAIO,QAAUL,GAGbF,GAoSAQ,CACLhE,EACAC,EACA2B,EACAG,EACAC,EACK,OAALN,EACK,OAALC,GAjGsBsC,CAAyBjE,EAAIC,EAAI2B,EAAGG,EAAIC,EAAIN,EAAIC,GAEtEyB,GACEA,EACGc,QAAO,SAAAC,OACAC,EAAa7C,EAAeR,EAASf,EAAIC,EAAIkE,EAAG,GAAIA,EAAG,YACtDC,EAAalB,GAAMkB,EAAajB,KAExCR,SAAQ,SAAAwB,UAAMzB,EAAO2B,KAAKF,UAEzBG,EAAa7C,EACjBM,EACAC,EACAN,EACAC,EACAmB,EACAC,EACAC,EACAC,GAGIqB,GACJ5B,EAAO2B,KAAKC,MAIT5B,WAGO6B,EACdzE,EACAC,EACAkC,EACAC,EACAH,EACAC,EACAN,EACAC,mBAQA7B,EACAC,EACAkC,EACAC,SAEO,CACL,CAACpC,EAAGC,EAAGD,EAAImC,EAAGlC,GACd,CAACD,EAAImC,EAAGlC,EAAGD,EAAImC,EAAGlC,EAAImC,GACtB,CAACpC,EAAImC,EAAGlC,EAAImC,EAAGpC,EAAGC,EAAImC,GACtB,CAACpC,EAAGC,EAAImC,EAAGpC,EAAGC,IAfTyE,CAAqB1E,EAAGC,EAAGkC,EAAGC,GAAGuC,MAAK,mBAC3ChD,EAA0BM,EAAIC,EAAIN,EAAIC,0BC/tB1C,IAAMzC,EAAKC,KAAKD,GACVwF,EAAW,EAALxF,EACNyF,EAAYzF,EAAK,6BCyBrBwB,EACAC,EACAC,EACAC,EACA+D,YAAAA,IAAAA,EAAwB,UAWpBA,EARFC,IAAAA,aAAM,MAQJD,EAPFE,QAAAA,aAAU,OAORF,EANFG,WAAAA,aAAa,MAMXH,EALFI,WAAAA,aAAa,QAKXJ,EAJFK,SAAAA,aAAW,MAITL,EAHFM,OAAAA,aAAS,MAGPN,EAFFO,KAAAA,kBAEEP,EADFQ,UAAAA,gBAGIlF,EAAQa,EAASL,EAAIC,EAAIC,EAAIC,GAC7BwE,EAAO5E,EAAYC,EAAIC,EAAIC,EAAIC,GAC/ByE,WF4DqB5E,EAAYC,EAAYC,EAAYC,UACxD1B,KAAKoG,KAAK3E,EAAKF,GAAM,IAAMG,EAAKF,GAAM,IE7D3B6E,CAAa9E,EAAIC,EAAIC,EAAIC,MAKzCwE,EAA6B,GAArBJ,EAAWC,IACV,IAARL,GAAyB,IAAZC,GACbM,GAAa,CAAC,EAAG,EAAGK,UAAUC,SAASJ,GACxC,KAIMK,EAAKxG,KAAKyG,IAAI,EAAGzG,KAAK0G,IAAIR,EAAOJ,EAAUA,IAC3Ca,EAAK3G,KAAKyG,IAAI,EAAGzG,KAAK0G,IAAIR,EAAOM,EAAIT,MAG1BjE,EAAaP,EAAIC,EAAIT,EAAOyF,GAAxC7C,OAAKC,SAGO9B,EAAaL,EAAIC,EAAIX,EAAQf,KAAKD,GAAI4G,GAAlD9C,OAAKC,SAGO7B,EAAgB0B,EAAKC,EAAKC,EAAKC,EAAK,UAE9C,CAACH,EAAKC,YAAaC,EAAKC,EAAK/C,EAAOA,EAAOA,OAMhD6F,GAAO1E,EAAUnB,GAAS,GAAM,EAAI,GAAK,IAAMiF,GAAQ,EAAI,GAGzDa,EACJnB,EAAMzF,EAASiG,EAAM,CAACN,EAAYC,GAAa,CAAC,EAAG,IAAI,GAAQF,IAKhD1D,EAAgBV,EAAIC,EAAIC,EAAIC,EAAI,IAA1CsB,OAAIC,SAGIhB,EAAgBV,EAAIC,EAAIC,EAAIC,EAAI,GAAMmF,GAAhDhG,OAAIC,SAGGJ,EAAYG,EAAIC,EAAIkC,EAAIC,EAAKjD,KAAKD,GAAK,EAAK6G,KAIrC9E,EAAaP,EAAIC,EADzBI,EAASL,EAAIC,EAHtBX,OAAIC,QAIsCgF,GAArCnC,OAAKC,SAIO9B,EAAaL,EAAIC,EADzBE,EAASH,EAAIC,EAAIb,EAAIC,GACYiF,GAArClC,OAAKC,QAKNC,GAAKnC,EAASf,EAAIC,EAAIS,EAAIC,GAG1BwC,GAAKpC,EAASf,EAAIC,EAAIW,EAAIC,MAKbO,EAAgB0B,EAAKC,EAAKC,EAAKC,GAAK,IAAhDgD,SAAKC,YAGK9E,EAAgB0B,EAAKC,EAAKC,EAAKC,GAAK,GAAM+C,GAAtDG,SAAKC,YAGIvG,EAAYsG,GAAKC,GAAKH,GAAKC,GAAM/G,KAAKD,GAAK,EAAK6G,MAG7C3E,EAAgBpB,EAAIC,EAHnCkG,SAAKC,SAG4C,UAE5C,CAACtD,EAAKC,cAAeC,EAAKC,GAAKE,GAAID,GAAIhD,6BD1GhD,SACEQ,EACAC,EACA0F,EACAC,EACA1F,EACAC,EACA0F,EACAC,EACA5B,OAEI6B,EAAYC,EAAYC,EAAYC,WAFxChC,IAAAA,EAAwB,UAapBA,EARFC,IAAAA,aAAM,MAQJD,EAPFE,QAAAA,aAAU,QAORF,EANFG,WAAAA,aAAa,OAMXH,EALFI,WAAAA,aAAa,QAKXJ,EAJFK,SAAAA,aAAW,MAITL,EAHFM,OAAAA,aAAS,OAGPN,EAFFO,KAAAA,kBAEEP,EADFQ,UAAAA,gBAGItC,EAAMpC,EAAKuE,EACflC,EAAMpC,EAAKsE,EACX4B,EAAMR,EAAgB,EAAXpB,EACX6B,EAAMR,EAAgB,EAAXrB,EACXjC,EAAMpC,EAAKsE,EACXjC,EAAMpC,EAAKqE,EACX6B,EAAMR,EAAc,EAATrB,EACX8B,EAAMR,EAAc,EAATtB,EACX+B,EAAMvG,EAAK2F,EAAK,EAChBa,EAAMvG,EAAK2F,EAAK,EAChBH,EAAMvF,EAAK2F,EAAK,EAChBH,GAAMvF,EAAK2F,EAAK,EAGZtG,GAAQqB,EAAeR,EAASkG,EAAKC,EAAKf,EAAKC,KAG/Ce,GAAW1G,EAAYwG,EAAKC,EAAKf,EAAKC,OAG3B,IAAbe,GAAgB,KACXV,GAAWQ,EAAPP,GAAY3D,EAChB4D,GAAWR,EAAPS,GAAY3D,KACN7B,EAAgBqF,GAAIC,GAAIC,GAAIC,GAAI,IAA1C5G,SAAIC,SACLmH,GAAKrG,EAAS0F,GAAIC,GAAIC,GAAIC,UACzB,CAACH,GAAIC,GAAI1G,GAAIC,GAAI0G,GAAIC,GAAIQ,GAAIA,GAAIA,QAIpCrB,IAAO1E,EAAUnB,IAAS,GAAM,GAAK,EAAI,IAAMiF,GAAQ,EAAI,GAG7DkC,YDigB0BnH,UACvBf,KAAKoG,IAAIpG,KAAKoG,IAAIrF,GAAShB,EAAK,IAAMA,EAAK,IAAMA,EAAK,GClgBlDoI,CAAgBpH,IAEvBmH,GAAO,GAAKA,GAAO,MAAMA,GAAO,SAG9BE,YDoLN7G,EACAC,EACA0F,EACAC,EACA1F,EACAC,EACA0F,EACAC,WAES9F,GAAME,EAAK2F,GAAM3F,GAAMF,EAAK2F,GAAM1F,GAAME,EAAK2F,GAAM3F,GAAMF,EAAK2F,GC7LnDkB,CAClB1E,EACAC,EACA8D,EACAC,EACA9D,EACAC,EACA8D,EACAC,eDsgBFtG,EACAC,EACA0F,EACAC,EACAmB,EACA7G,EACAC,EACA0F,EACAC,EACAkB,OAEMT,EAAMvG,EAAK2F,EAAK,EACpBa,EAAMvG,EAAK2F,EAAK,EAChBH,EAAMvF,EAAK2F,EAAK,EAChBH,EAAMvF,EAAK2F,EAAK,KACC1E,EACfmF,EACAC,EACAf,EAAMc,EACNb,EAAMc,EACNxG,EACAC,EACA0F,EACAC,EACAmB,IACG,CAAC,CAACR,EAAKC,QAVVS,OAAMC,UAWS9F,EACfqE,EACAC,EACAa,EAAMd,EACNe,EAAMd,EACNxF,EACAC,EACA0F,EACAC,EACAkB,IACG,CAAC,CAACvB,EAAKC,cAEP,CAACuB,EAAMC,aCxiBmBC,CAC/B/E,EACAC,EACA8D,EACAC,EACA7B,EACAjC,EACAC,EACA8D,EACAC,EACA9B,GAVK4C,SAAMC,SAAMC,SAAMC,SAcnBC,GAAkBzH,EAAYqH,GAAMC,GAAMC,GAAMC,QAKjDV,IAAenC,GAAaiC,GAAO,IAAQ,EAAG,QAC5BjG,EAAgB0G,GAAMC,GAAMC,GAAMC,GAAM,UACtD,CAACH,GAAMC,eAAkBC,GAAMC,GAAM/H,GAAOA,GAAQhB,EAAIgB,QAM7DiI,GAAgBZ,GAChBnI,EAAS8I,GAAiB,CAAC,EAAGf,IAAW,CAAC,EAAG,IAAI,GACjD,EAGEiB,GAAa,EAAIF,GAAkBf,GAWrCnB,GAAMnB,EARYzF,EACpB8I,GACA,CAACnD,EAAYC,GACb,CAAC,EAAG,IACJ,GAI8BF,EAG5BuD,GAAcjJ,EAChBiI,GAAOA,IACN,EAAG,GACJ,CAAM,KAALnI,EAAY,IACb,GAGIoJ,GAAaf,GACV,GAALrI,EAAWmI,GACXjI,EACEgJ,IACC,IAAM,GACP,CAAC,EAAQ,GAALlJ,IACJ,GACEmI,MAcWxF,KALjBsG,IAAiB,GACbjI,GAAQhB,EAAK6G,GACb7F,GAAQf,KAAKyG,IAAIjB,EARrB2D,GAAaD,IAAed,GAAc,EAAIY,GAAgB,IAQZpC,IAGRrB,GAAK6D,YAAY,IAAtDC,SAAKC,YAGS3G,EACnBmF,EACAC,EACAsB,GACAC,GACA3F,EACAC,EACA8D,EACAC,EACA7B,MATMyD,SAAKC,SAaPC,GAAWrE,EACfzB,EACAC,EACA8D,EACAC,EACAG,EACAC,EACAsB,GACAC,QAGGG,GAAU,MAAMC,aAIAzH,EADYwH,MAAAA,MAAAA,MAAAA,MAC4B,IAAtDE,SAAMC,YACD3H,EACVsH,GACAC,GACAG,GACAC,GACAxB,GAAcpI,KAAKyG,IAAIuC,GAAe,KAAQ,QAL9C1B,QAAIC,QAQNV,IAAO,GAAK7G,KAAKyG,KAAK,EAAGzG,KAAK0G,IAAIuC,GAAY,IAAMf,GAAOc,IAAiB,EAExEZ,KACFvB,GAAMA,GAAM,EAAI7G,KAAK0G,IAAIG,IAAM,IAAO7G,KAAKyG,IAAII,GAAK,KAKlDmC,IAAiB,GAAK,QAGLtG,EADFd,EAASkG,EAAKC,EAAK4B,GAAMC,QAE5BjH,EACZqE,EACAC,eAGApD,EACAC,EACA8D,EACAC,EACA9B,MATCyB,QAAIC,YAWF,KAECoC,GAAc5J,EAASgJ,GAAY,CAAC,IAAM,GAAI,CAAC,EAAG,IAAI,GAEtDa,GAAiB1B,GACnBnI,EAAS+I,GAAe,CAAC,EAAG,GAAI,CAAC,EAAGjJ,EAAK,IAAI,GAC7C,EAEEgK,GAAc9J,EAASiI,GAAO2B,GAAa,CAAC,EAAG,GAAI,CAAC,EAAG9J,EAAK,KAAK,MAapD2C,KALjBsG,IAAiB,GACbjI,GAAQhB,EAAK6G,GACb7F,GAAQhB,EAAKC,KAAKyG,IAPtBwC,IAAclJ,EAAK,KAClBgK,GAAcD,KACdX,GAAaD,IAAe,EAKa1D,GAAaoB,IAGbrB,GAAK6D,YAAY,IAAtDY,SAAKC,YAGStH,EACnBqE,EACAC,GACA+C,GACAC,GACApG,EACAC,EACA8D,EACAC,EACA9B,MATMmE,SAAKC,SAaPC,GAAShF,EACbvB,EACAC,EACA8D,EACAC,EACAb,EACAC,GACA+C,GACAC,QAGGG,GAAQ,MAAMV,aAGEzH,EADYmI,MAAAA,MAAAA,MAAAA,MAC4B,OAGjDnI,EACViI,GACAC,eAGA,IAAuB,IAAhBnB,IALPxB,QAAIC,eAYWxF,EAAgBqF,EAAIC,EAAIC,EAAIC,EAAI,IAA5CX,SAAKC,YACO9E,EACjBqF,EACAC,EACAC,EACAC,EACAzH,KAAKyG,KAAK,EAAGzG,KAAK0G,IAAI,EAAG,GAAMG,MAL1BwD,SAAKC,YASS5J,EAAY2J,GAAKC,GAAKxD,GAAKC,GAAMhH,EAAK,EAAK6G,IAAzD2D,SAAMC,YACQ9J,EAAY2J,GAAKC,GAAKxD,GAAKC,GAAMhH,EAAK,GAAM6G,IAA1D6D,SAAMC,YAIXtC,IACA9G,EAAYiJ,GAAMC,GAAMxD,EAAKC,IAAO3F,EAAYmJ,GAAMC,GAAM1D,EAAKC,IAC7D,CAACwD,GAAMC,IACP,CAACH,GAAMC,IAJRG,SAAKC,SAOJ7G,GAAKnC,EAAS+I,GAAKC,GAAKtD,EAAIC,SAG3B,CAACD,EAAIC,EAAIoD,GAAKC,GAAKpD,EAAIC,EAFnB7F,EAAS+I,GAAKC,GAAKpD,EAAIC,GAEI1D,GAAInC,EAAS0F,EAAIC,EAAIC,EAAIC"}